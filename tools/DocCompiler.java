// $Id: DocCompiler.java,v 1.15 1999/03/11 10:41:10 alex Exp $
// Compiler to generate documentation files.
// Matthew Caldwell, 8 October 1998
// Copyright (c) Ogalala Limited <info@ogalala.com>

package com.ogalala.tools;

import com.ogalala.util.*;
import com.ogalala.mua.*;
import java.util.*;
import java.io.*;

/**
 *  The doc compiler reads an optional database file and
 *  any number of script files and produces documentation
 *  for some or all of the atoms defined therein. The
 *  documentation consists of inheritance information,
 *  properties and their values, and any documentation
 *  comments (those that start "##") defined for the atoms
 *  or their properties in the scripts.
 *  <p>
 *  By default, the compiler uses a temporary database,
 *  which is deleted when the compilation completes,
 *  but it can use an existing database or generate a
 *  new one. Note that a database file will only contain
 *  comments if it was created by a tool that supports them,
 *  such as this compiler.
 *  <p>
 *  If an existing database is used, any script files processed
 *  at the same time will be added to the database permanently.
 *  If in doubt, operate on a copy!
 *  <p>
 *  This compiler is more forgiving of script dependencies than
 *  the game itself, provided that scripts have correct #import
 *  directives (eg, as generated by the ODLCompiler). Dependencies
 *  which are not satisfied in the database at the time a file
 *  is processed are created as empty atoms, and then replaced
 *  later if an explicit creation command is encountered. This
 *  should mean that script subsets can be documented without
 *  having to recompile the whole world, but it may result in
 *  incorrectly empty ancestors for some atoms, and particularly
 *  may cause problems if the same database file is to be used
 *  with other tools. As an additional consequence, successful
 *  processing by this tool does not imply that a script will
 *  work in the game itself!
 *  <p>
 */
public class DocCompiler
	implements Runnable
{
	//-------------------------------------------------------------
	//  instance variables
	//-------------------------------------------------------------

	/**
	 *  The thread with which the <tt>run()</tt> method is
	 *  executed when the class is run as an application.
	 */
	protected Thread runThread = null;

	/**
	 *  The list of script files to be processed, as provided
	 *  on the command line.
	 */
	protected Vector sources = null;

	/**
	 *  The list of specific atoms to be documented. If this is
	 *  <tt>null</tt>, the compiler outputs documentation for
	 *  the entire atom database.
	 */
	protected Vector atoms = null;

	/**
	 *  The name of an atom database file into which the
	 *  imported atoms should be inserted. If this is not
	 *  provided, a temporary database called
	 *  <tt>scratch_db.atom</tt> will be generated, and then
	 *  deleted once the compilation finishes.
	 */
	protected String dbName = DEFAULT_DB;

	/**
	 *  A string to be prefixed to all output filenames. By
	 *  default, output files are called <i>name</i><tt>.html</tt>,
	 *  where <i>name</i> is the name of the atom that the file
	 *  documents. If an output prefix is provided, output files
	 *  will be called <i><b>prefix</b>name</i><tt>.html</tt>.
	 *  On most systems the prefix may be a pathname, in which
	 *  case the files will be created in the appropriate path.
	 *  Note, however, that the directory structure must already
	 *  exist -- the program will probably throw an exception if
	 *  the prefix points to a non-existent directory.
	 */
	protected String outputPrefix = "".intern();

	/**
	 *  The root name of a file to which the noun list should
	 *  be exported. If this is not provided, no noun list
	 *  is produced.
	 */
	protected String nounFile = null;

	/**
	 *  A stream to which error messages are written. This will
	 *  commonly be System.err (or a PrintWriter wrapper for it),
	 *  but can optionally be a log file.
	 */
	protected PrintWriter err = null;

	/**
	 *  A flag indicating whether the error file needs to be
	 *  closed before the program exits. If System.err is
	 *  being used, the program should not close the file itself.
	 */
	protected boolean closeErrFile = false;

	/**
	 *  A dummy game world used as a wrapper for AtomDatabase.
	 */
	protected DummyWorld world = null;

	/**
	 *  The atom database that maintains the inheritance
	 *  relationships of all processed atoms.
	 */
	protected AtomDatabase data = null;

	/**
	 *  The current container assigned to things when they
	 *  are created.
	 */
	protected Container where = null;

	/**
	 *  A table of all the nouns and the names of
	 *  the atoms on which they are defined.
	 */
	protected Hashtable nouns = new Hashtable ();

	/**
	 *  A list of the currently running script files. This
	 *  is used to preempt mutually recursive "!run" commands.
	 */
	protected Vector openFiles = new Vector ();

	/**
	 *  The name of a file into which a dependency script
	 *  should be generated.
	 */
	protected String mapFile = DEFAULT_MAP_FILE;

	/**
	 *  Path to search for scripts. By default only the current
	 *  directory is searched. This may be changed with the
	 *  -s command line option.
	 */
	protected String scriptPath = ".";

	//-------------------------------------------------------------
	//  class variables
	//-------------------------------------------------------------

	/**
	 *  A reference to the application object if the class
	 *  is being run as an application. This is instantiated
	 *  by <tt>main()</tt>.
	 */
	protected static DocCompiler theApp = null;

	/**
	 *  The name of the atom database file that is created if no
	 *  database is specified on the command line.
	 */
	protected static final String DEFAULT_DB = "scratch_db.atom".intern();

	/**
	 *  The name of a file to which any script file dependencies
	 *  should be written if none are specified.
	 */
	protected static final String DEFAULT_MAP_FILE = "dependency.map";

	//-------------------------------------------------------------
	//  construction
	//-------------------------------------------------------------

	/**
	 *  The default constructor does nothing, on the assumption
	 *  that any initialization will be done by <tt>init()</tt>.
	 *  If the class is to be instantiated other than via the
	 *  standard invocation of <tt>main()</tt>, it may be
	 *  useful to provide other constructors.
	 */
	public DocCompiler ()
	{
	}

	//-------------------------------------------------------------
	//  application shell
	//-------------------------------------------------------------

	/**
	 *  Create an object of the compiler class and run it.
	 */
	public static void main ( String[] args )
	{
		theApp = new DocCompiler();

		// initialize and run
		if ( theApp.init(args) )
		{
			theApp.runThread = new Thread ( theApp );
			theApp.runThread.start();
		}
	}

	//-------------------------------------------------------------

	/**
	 *  Do any necessary initialization from the command-line
	 *  arguments.

	 @return  Whether the app successfully initialized.

	 */
	public boolean init ( String[] args )
	{
		// nothing comes of nothing
		if ( args.length == 0 )
		{
			printUsage();
			return false;
		}

		// process command-line options
		int argPtr = 0;
		String errName = null;

		while ( true )
		{
			// handle options
			if ( argPtr >= args.length )
				break;

			// -h: help
			if ( "-h".equals(args[argPtr])
				 || "--help".equals(args[argPtr])
				 || "-?".equals(args[argPtr]) )
			{
				printUsage();
				argPtr++;
			}
			// -p: prefix
			else if ( "-p".equals(args[argPtr]) )
			{
				if ( argPtr + 1 < args.length )
				{
					outputPrefix = args[argPtr + 1];
					argPtr += 2;
				}
				else
				{
					System.err.println ( "ERROR: option -p requires an argument" );
					return false;
				}
			}
			// -s: script path
			else if ( "-s".equals(args[argPtr]) )
			{
				if ( argPtr + 1 < args.length )
				{
					scriptPath = args[argPtr + 1];
					argPtr += 2;
				}
				else
				{
					System.err.println ( "ERROR: option -s requires an argument" );
					return false;
				}
			}
			// -e: error file
			else if ( "-e".equals(args[argPtr]) )
			{
				if ( argPtr + 1 < args.length )
				{
					errName = args[argPtr + 1];
					argPtr += 2;
				}
				else
				{
					System.err.println ( "ERROR: option -e requires an argument" );
					return false;
				}
			}
			// -m: dependency map file
			else if ( "-m".equals(args[argPtr]) )
			{
				if ( argPtr + 1 < args.length )
				{
					mapFile = args[argPtr + 1];
					argPtr += 2;
				}
				else
				{
					System.err.println ( "ERROR: option -m requires an argument" );
					return false;
				}
			}
			// -n: nouns file
			else if ( "-n".equals(args[argPtr]) )
			{
				if ( argPtr + 1 < args.length )
				{
					nounFile = args[argPtr + 1];
					argPtr += 2;
				}
				else
				{
					System.err.println ( "ERROR: option -n requires an argument" );
					return false;
				}
			}
			// -d: database file
			else if ( "-d".equals(args[argPtr]) )
			{
				if ( argPtr + 1 < args.length )
				{
					dbName = args[argPtr + 1];
					argPtr += 2;
				}
				else
				{
					System.err.println ( "ERROR: option -d requires an argument" );
					return false;
				}
			}
			// -a: atoms
			else if ( "-a".equals(args[argPtr]) )
			{
				if ( argPtr + 1 < args.length )
				{
					if ( atoms == null )
						atoms = new Vector ();

					argPtr++;

					while ( argPtr < args.length && !args[argPtr].startsWith("-") )
					{
						atoms.addElement ( args[argPtr] );
						argPtr++;
					}
				}
				else
				{
					System.err.println ( "ERROR: option -a requires one or more arguments" );
					return false;
				}
			}
			// -f: files
			else if ( "-f".equals(args[argPtr]) )
			{
				if ( argPtr + 1 < args.length )
				{
					if ( sources == null )
						sources = new Vector ();

					argPtr++;

					while ( argPtr < args.length && !args[argPtr].startsWith("-") )
					{
						sources.addElement ( args[argPtr] );
						argPtr++;
					}
				}
				else
				{
					System.err.println ( "ERROR: option -f requires one or more arguments" );
					return false;
				}
			}
			// unknown arguments
			else
			{
				System.err.println ( "ERROR: Unknown option: " + args[argPtr] );
				printUsage();
				return false;
			}
		}

		// there must be some atoms to document, either from script
		// files or an existing database -- if neither, there's nothing
		// to be done, so just warn and exit
		if ( sources == null && dbName == DEFAULT_DB )
		{
			System.err.println ( "WARNING: nothing to be documented." );
			return false;
		}

		// create the error file, if any
		try
		{
			if ( errName == null )
				err = new PrintWriter ( System.err, true );
			else
				err = new PrintWriter ( new FileWriter ( errName ), true );

			// since we opened the file, we must remember to close it
			closeErrFile = true;
		}
		catch ( IOException e )
		{
			System.err.println ( "WARNING: Unable to create error file " + errName + ": " + e );
			System.err.println ( "Errors will be written to System.err" );
			err = new PrintWriter ( System.err );
		}

		// attempt to create the world and get the database
		try
		{
			world = new DummyWorld ( dbName );
			data = world.getPublicAtomDatabase ();
			where = data.getLimbo();

			// set the world's script path
			world.addPath ( scriptPath );
		}
		catch ( IOException e )
		{
			// it's arguable that this should be written to err, but
			// I'd say all initialization errors get written together
			System.err.println ( "ERROR: Unable to open database file " + dbName + ": " + e );
			return false;
		}

		// initialization succeeded
		return true;
	}

	//-------------------------------------------------------------

	/**
	 *  The main application procedure. When this exits, the
	 *  initial thread will end. The application itself may
	 *  continue, however, if other threads have been started
	 *  (notably the AWT event handling thread).
	 */
	public void run ()
	{
		// read any additional scripts and modify the
		// database accordingly
		if ( sources != null && sources.size() > 0 )
		{
			// if the source list contains only 1 file we
			// don't have to worry about dependencies
			if ( sources.size() == 1 )
			{
				readScript ( (String) sources.elementAt(0), null );
			}
			else
			{
				// we must first invoke the dependency compiler
				// and then run the dependency script

				// create the dependency compiler arg list
				String[] args = new String [ sources.size() + 2 ];
				args[0] = "-o";
				args[1] = mapFile;

				for ( int i = 0; i < sources.size(); i++ )
					args[i+2] = (String) sources.elementAt(i);

				DependencyCompiler dep = new DependencyCompiler();
				dep.setErr(err);
				dep.init(args);
				dep.run();

				// if compilation failed, we can't go on
				if ( ! dep.succeeded )
				{
					err.println ( "ERROR: dependency failure -- compilation aborted" );
					return;
				}

				// run the dependency script
				readScript ( mapFile, null );
			}
		}

		// output the documentation for the specified atoms
		if ( atoms == null )
		{
			writeAllDocs ();
		}
		else
		{
			Enumeration enum = atoms.elements();
			while ( enum.hasMoreElements() )
				writeDocs ( (String) enum.nextElement() );
		}

		// export the nouns table (if so instructed on the command line)
		writeNouns();

		// close the world database
		try { world.close(); }
		catch ( IOException e )
		{
			err.println ( "WARNING: Exception thrown when closing database: " + e );
		}

		// if we're using a temporary database, delete it
		if ( dbName == DEFAULT_DB )
		{
			data.delete ( DEFAULT_DB );
		}

		// close the error log file if necessary
		if ( closeErrFile )
		{
			err.flush();
			err.close();
		}
	}

	//-------------------------------------------------------------
	//  reading
	//-------------------------------------------------------------

	/**
	 *  Read a script and parse its contents into the atom
	 *  database. The script file is processed one line at
	 *  a time and each command dispatched to the relevant
	 *  handler. Plain comments are discarded, documentation
	 *  comments are accumulated and supplied to the
	 *  relevant command handler.
	 *  <p>
	 *  This method may be called recursively, so all cumulative
	 *  values are kept as local variables on the stack.
	 *  <p>
	 *  Errors encountered when reading files or executing
	 *  the commands they contain are written to <tt>err</tt>,
	 *  but don't abort the compilation process.

	 @param fileName     The name of the script file to be run.
	 @param callingFile  The name of the file containing
	 */
	public void readScript ( String fileName,
							 String callingTag )
	{
		// files for !run are searched on the script path
		// they can't have any path of their own, so
		// remove any pathname supplied with the file
		File file = new File ( fileName );
		fileName = file.getName();

		int lineNumber = 0;
		String lineTag = "(" + fileName + ":" + lineNumber + ")";

		// locate the file on the filepath, if possible
		file = world.findFile( fileName );

		// note that the file is running so it can't
		// recursively run itself
		openFiles.addElement( file.getName().intern() );

		try
		{
			BufferedReader in = new BufferedReader ( new FileReader ( file ) );

			String comments = "";

			while ( true )
			{
				String line = in.readLine();

				// exit the loop when we run out of input
				if ( line == null )
					break;

				line = line.trim();
				lineNumber++;

				// comment lines that start with 3 or more '#' characters
				// are discarded without another thought
				if ( line.startsWith("###") )
					continue;

				// append continuation lines (but not to comment lines)
				if ( ! line.startsWith("#") )
				{
					while ( line.endsWith("\\") )
					{
						String nextLine = in.readLine();

						// drop the trailing backslash
						line = line.substring( 0, line.length() - 1 );

						// append the next line, if any
						if ( nextLine != null )
						{
							line += nextLine.trim();
							lineNumber++;
						}
					}
				}

				// append doc comments to our current comment buildup
				if ( line.startsWith("##") )
				{
					comments += "\r\n" + line.substring( 2, line.length() );
				}
				// ignore empty lines
				else if ( line.equals("") )
				{
				}
				// tokenize everything else and despatch on the first token
				else
				{
					// update the line tag
					lineTag = "(" + fileName + ":" + lineNumber + ")";

					StringTokenizer tokenizer = new StringTokenizer ( line );

					String token = tokenizer.nextToken();

					// AtomExceptions may be thrown anywhere without
					// declaration, so make sure they're caught
					try
					{
						// despatch to the relevant handler and
						// reset comments if necessary
						if ( "#import".equalsIgnoreCase( token ) )
						{
							doImport ( tokenizer, lineTag );
						}
						else if ( "!run".equalsIgnoreCase( token ) )
						{
							doRun ( tokenizer, lineTag );
						}
						else if ( "!atom".equalsIgnoreCase( token ) )
						{
							doAtom ( tokenizer, comments, lineTag );
							comments = "";
						}
						else if ( "!new".equalsIgnoreCase( token ) )
						{
							doNew ( tokenizer, comments, lineTag );
							comments = "";
						}
						else if ( "!go".equalsIgnoreCase( token ) )
						{
							doGo ( tokenizer, lineTag );
						}
						else if ( "!set".equalsIgnoreCase( token ) )
						{
							// set takes the line as well as the tokenizer
							// because it needs more complex access to the
							// args than StringTokenizer provides
							doSet ( tokenizer, line, comments, lineTag );
							comments = "";
						}
						else if ( "!inherit".equalsIgnoreCase( token ) )
						{
							doInherit ( tokenizer, lineTag );
						}
						else if ( "!uninherit".equalsIgnoreCase( token ) )
						{
							doUninherit ( tokenizer, lineTag );
						}
						else if ( "!noun".equalsIgnoreCase( token ) )
						{
							doNoun ( tokenizer, lineTag );
						}
						else if ( ! token.startsWith("#") )
						{
							// warn about unknown commands
							err.println ( "WARNING: "
										  + lineTag
										  + " unknown command: \""
										  + token + "\"" );
						}
					}
					catch ( AtomException x )
					{
						err.println ( "ERROR: "
									  + lineTag
									  + " exception thrown processing command: "
									  + x );
					}
				}
			}
		}
		catch ( IOException e )
		{
			if ( callingTag != null )
				err.println ( "ERROR: "
							  + lineTag
							  + "[run from "
							  + callingTag
							  + "] exception reading file: "
							  + e );
			else

				err.println ( "ERROR: "
							  + lineTag
							  + " exception reading file: "
							  + e );
		}

		// file is no longer running, so could conceivably be
		// run again -- may want to remove this so every script
		// can only be run once?
		openFiles.removeElement( file.getName().intern() );
	}

	//-------------------------------------------------------------

	/**
	 *  Run a script file. This is a recursive process that could
	 *  cause a stack overflow, but so be it. This method does
	 *  guard against looping, by keeping a list of all running
	 *  files and making sure that the new file is not in the
	 *  list before running it. The actual running is done
	 *  by the <tt>readScript()</tt> method.
	 */
	protected void doRun ( StringTokenizer cmd,
						   String lineTag )
	{
		// get the name of the file to be run
		if ( cmd.hasMoreTokens() )
		{
			// assumes we're using case-sensitive filenames,
			// which may be wrong, but scripts should be written
			// with this in mind, since the server will be
			// running on case-sensitive Unix (probably)
			String newFile = cmd.nextToken().intern();
			if ( openFiles.contains(newFile) )
			{
				err.println ( "ERROR: "
							  + lineTag
							  + " attempt to run already-running script "
							  + newFile );
			}
			else
			{
				readScript ( newFile, lineTag );
			}
		}
		else
			err.println ( "WARNING: "
						  + lineTag
						  + " no filename supplied to !RUN" );
	}

	//-------------------------------------------------------------

	/**
	 *  Execute the "!new" command according to the supplied
	 *  command-line arguments. Create a new thing in the game
	 *  database, inheriting from the specified parents, and
	 *  associating the specified comments with it.
	 *  <p>
	 *  Thing comments are stored in a property whose name
	 *  is the thing's id prefixed with a double underscore.
	 *  <p>
	 *  As with the standard ModNewThing action, the parents are
	 *  sorted to create the correct static type. If no parents
	 *  are specified, the new thing inherits from "thing".
	 *  <p>
	 *  For the purposes of this compiler, atoms (and things)
	 *  have a special property "__" which contains either
	 *  the value "dummy" (indicating that the atom is a fake
	 *  created to satisfy a declared dependency) or a string
	 *  containing the name of the file in which the atom was
	 *  created and the line number of the relevant "!atom"
	 *  or "!new" command. In cases of multiple definitions,
	 *  the second and subsequent creation commands fail and
	 *  report where the original creation occurred.
	 */
	protected void doNew ( StringTokenizer cmd,
						   String comments,
						   String lineTag )
	{
		if ( ! cmd.hasMoreElements() )
		{
			err.println( "ERROR: "
						 + lineTag
						 + " no thing ID supplied to !NEW" );
			return;
		}

		String thingID = (String) cmd.nextToken();

		Atom thing = data.getAtom(thingID);
		if ( thing != null )
		{
			String origin = (String) thing.getField("__");
			err.print( "ERROR: "
					   + lineTag
					   + " attempt to recreate thing \""
					   + thingID
					   + "\" " );

			if ( origin == null )
			{
				err.println ( "(original source unknown)" );
			}
			else if ( origin.equals("dummy") )
			{
				err.println ( "previously created as " + origin );
			}
			else
			{
				err.println ( "previously created at " + origin );
			}

			return;
		}

		// generate a sorted list of parents
		AtomVector parents = new AtomVector();

		while ( cmd.hasMoreElements() )
		{
			String parentID = (String) cmd.nextToken();
			Atom parent = data.getAtom ( parentID );
			if ( parent == null )
			{
				err.println( "WARNING: "
							 + lineTag
							 + " creating dummy for non-existent parent in !NEW: "
							 + parentID );
				parent = createDummy( parentID, lineTag );
			}

			parents.put ( parent );
		}

		parents.sort();

		// create the thing
		if ( parents.size() == 0 )
			thing = world.newThing ( thingID, data.getAtom(AtomDatabase.THING_ID) );
		else
			thing = world.newThing ( thingID, parents.get(parents.size() - 1) );

		// inherit from the other parents, in reverse order
		if ( parents.size() > 1 )
		{
			for ( int i = parents.size() - 2; i >= 0; i-- )
				thing.inherit(parents.get(i));
		}

		// move the thing to the current location (if it *is* a thing)
		if ( thing instanceof Thing && where != null )
			where.putIn(thing);

		// add the source field
		thing.setField("__", lineTag);

		// if there are any comments, add them
		if ( comments != null && comments.length() > 0 )
			thing.setField("__" + thingID, comments);
	}

	//-------------------------------------------------------------

	/**
	 *  Execute the "!atom" command according to the supplied
	 *  command-line arguments. Create a new atom in the game
	 *  database, inheriting from the specified parents and
	 *  associating the specified comments with it.
	 *  <p>
	 *  Atom comments are stored in a property whose name is
	 *  the atom's id prefixed with a double underscore.
	 *  <p>
	 *  For the purposes of this compiler, atoms (and things)
	 *  have a special property "__" which contains either
	 *  the value "dummy" (indicating that the atom is a fake
	 *  created to satisfy a declared dependency) or a string
	 *  containing the name of the file in which the atom was
	 *  created and the line number of the relevant "!atom"
	 *  or "!new" command. In cases of multiple definitions,
	 *  the second and subsequent creation commands fail and
	 *  report where the original creation occurred.
	 */
	protected void doAtom ( StringTokenizer cmd,
						    String comments,
						    String lineTag )
	{
		if ( ! cmd.hasMoreElements() )
		{
			err.println( "ERROR: "
						 + lineTag
						 + " no atom ID supplied to !ATOM" );
			return;
		}

		String atomID = (String) cmd.nextToken();

		Atom atom = data.getAtom(atomID);
		if ( atom != null )
		{
			String origin = (String) atom.getField("__");
			err.print( "ERROR: "
					   + lineTag
					   + " attempt to recreate atom \""
					   + atomID
					   + "\" " );

			if ( origin == null )
			{
				err.println ( "(original source unknown)" );
			}
			else if ( origin.equals("dummy") )
			{
				err.println ( "previously created as a dummy" );
			}
			else
			{
				err.println ( "previously created at " + origin );
			}

			return;
		}

		// generate a sorted list of parents
		AtomVector parents = new AtomVector();

		while ( cmd.hasMoreElements() )
		{
			String parentID = (String) cmd.nextToken();
			Atom parent = data.getAtom ( parentID );
			if ( parent == null )
			{
				err.println( "WARNING: "
							 + lineTag
							 + " creating dummy for non-existent parent in !ATOM: "
							 + parentID );
				parent = createDummy( parentID, lineTag );
			}

			parents.put ( parent );
		}

		parents.sort();

		// create the atom
		if ( parents.size() == 0 )
			atom = data.newAtom ( atomID, data.getRoot() );
		else
			atom = data.newAtom ( atomID, parents.get(parents.size() - 1) );

		// inherit from the other parents, in reverse order
		if ( parents.size() > 1 )
		{
			for ( int i = parents.size() - 2; i >= 0; i-- )
				atom.inherit(parents.get(i));
		}

		// add the source field
		atom.setField("__", lineTag);

		// if there are any comments, add them
		if ( comments != null && comments.length() > 0 )
			atom.setField("__" + atomID, comments);
	}

	//-------------------------------------------------------------

	/**
	 *  Set the given property on an atom according to the
	 *  supplied command-line arguments, associating
	 *  the specified comments with it.
	 *  <p>
	 *  Property comments are stored in a property whose name
	 *  is the property name prefixed with a double underscore.
	 */
	protected void doSet ( StringTokenizer cmd,
						   String cmdLine,
						   String comments,
						   String lineTag )
	{
		if ( ! cmd.hasMoreTokens() )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " no arguments to !SET" );
			return;
		}

		// get the atom.field tag
		String atomField = cmd.nextToken();

		// the rest of the line is the value -- this will be wrong if
		// the atomField is a substring of !set, but that's an error
		// anyway
		String value = null;
		try
		{
			value = cmdLine.substring ( cmdLine.indexOf( atomField )
										+ atomField.length() ).trim();
		}
		catch ( ArrayIndexOutOfBoundsException e )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " no value supplied for !SET "
						  + atomField );
			return;
		}

		// split the atom.field tag into an atom ID and a field ID
		String atomID = null, fieldID = null;

		try
		{
			atomID = atomField.substring ( 0, atomField.indexOf('.') );
			fieldID = atomField.substring ( atomField.indexOf('.') + 1 );
		}
		catch ( ArrayIndexOutOfBoundsException e )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " invalid property specifier for !SET: \""
						  + atomField
						  + "\"" );
			return;
		}

		Atom atom = data.getAtom ( atomID );

		if ( atom == null )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " attempt to set property of non-existent atom: \""
						  + atomID
						  + "\"" );
			return;
		}

		// check that the field name is valid
		if ( ! Atom.isValidID ( fieldID ) )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " invalid property name: \""
						  + fieldID
						  + "\"" );
			return;
		}

		// set the value
		atom.setField( fieldID, atom.parseField(value) );

		// set the value comments, if any
		if ( comments != null && comments.length() > 0 )
			atom.setField( "__" + fieldID, comments );
	}

	//-------------------------------------------------------------

	/**
	 *  Execute the "!inherit" command according to the
	 *  supplied command-line arguments. If either the
	 *  atom or the new parent does not exist in the atom
	 *  database, it is created as a dummy and a warning
	 *  is given.
	 */
	protected void doInherit ( StringTokenizer cmd,
							   String lineTag )
	{
		// extract args
		if ( ! cmd.hasMoreTokens() )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " no arguments to !INHERIT" );
			return;
		}

		String atomID = cmd.nextToken();

		if ( !cmd.hasMoreTokens() )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " no parent provided for !INHERIT" );
			return;
		}

		String parentID = cmd.nextToken();

		if ( cmd.hasMoreTokens() )
		{
			err.println ( "WARNING: "
						  + lineTag
						  + " too many arguments to !INHERIT" );
		}

		Atom parent = data.getAtom ( parentID );

		if ( parent == null )
		{
			err.println ( "WARNING: "
						  + lineTag
						  + " creating dummy for non-existent parent in !INHERIT: \""
						  + parentID
						  + "\"" );
			parent = createDummy ( parentID, lineTag );
		}

		Atom atom = data.getAtom ( atomID );

		if ( atom == null )
		{
			err.println ( "WARNING: "
						  + lineTag
						  + " creating dummy for non-existent child in !INHERIT: \""
						  + atomID
						  + "\"" );
			atom = data.newAtom ( atomID, parent );

			// mark the atom as a dummy
			atom.setField ( "__", "dummy " + lineTag );

			// already inherits from parent, so we can just return
			return;
		}

		atom.inherit(parent);
	}

	//-------------------------------------------------------------

	/**
	 *  Execute the "!uninherit" command according to the
	 *  supplied command-line arguments. If the atom does
	 *  not exist or does not have the specified parent,
	 *  a warning is emitted.
	 */
	protected void doUninherit ( StringTokenizer cmd,
								 String lineTag )
	{
		// extract args
		if ( ! cmd.hasMoreTokens() )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " no arguments to !UNINHERIT" );
			return;
		}

		String atomID = cmd.nextToken();

		if ( !cmd.hasMoreTokens() )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " no parent provided for !UNINHERIT" );
			return;
		}

		String parentID = cmd.nextToken();

		if ( cmd.hasMoreTokens() )
		{
			err.println ( "WARNING: "
						  + lineTag
						  + " too many arguments to !UNINHERIT" );
		}

		Atom parent = data.getAtom ( parentID );

		if ( parent == null )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " non-existent parent to !UNINHERIT: \""
						  + parentID
						  + "\"" );
			return;
		}

		Atom atom = data.getAtom ( atomID );

		if ( atom == null )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " non-existent child to !UNINHERIT: \""
						  + atomID
						  + "\"" );
			return;
		}

		atom.uninherit(parent);
	}

	//-------------------------------------------------------------

	/**
	 *  Execute the "!go" command according to the supplied
	 *  command-line arguments. If the specified location
	 *  does not exist it is created as a dummy and a warning
	 *  given. If it exists but is not a container, an error
	 *  results.
	 */
	protected void doGo ( StringTokenizer cmd,
						  String lineTag )
	{
		if ( ! cmd.hasMoreTokens() )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " no arguments to !GO" );
			return;
		}

		String whereID = cmd.nextToken();

		if ( cmd.hasMoreTokens() )
		{
			err.println ( "WARNING: "
						  + lineTag
						  + " too many arguments to !GO" );
		}

		Atom container = data.getAtom ( whereID );

		if ( container == null )
		{
			err.println ( "WARNING: "
						  + lineTag
						  + " creating non-existent !GO destination as a dummy: \""
						  + whereID
						  + "\"" );
			where = (Container) data.newAtom ( whereID,
											   data.getAtom(AtomDatabase.CONTAINER_ID) );
		}
		else if ( container instanceof Container )
		{
			where = (Container) container;
		}
		else
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " !GO destination is not a container: \""
						  + whereID
						  + "\"" );
		}

	}

	//-------------------------------------------------------------

	/**
	 *  Execute the "#import" script directive. The atom
	 *  database is checked to ensure it contains all the
	 *  specified atoms, and if it doesn't they are created
	 *  as descendants of the root atom.
	 *  <p>
	 *  Atoms that are created artificially here are
	 *  marked as such by the property "__", which has the
	 *  value "dummy". They may need to be replaced later
	 *  when the correct script actually creates them.
	 *  This is kind of painful, and still may not work,
	 *  see <tt>doAtom()</tt> and <tt>doNew()</tt> for
	 *  details.
	 */
	protected void doImport ( StringTokenizer cmd,
							  String lineTag )
	{
		while ( cmd.hasMoreTokens() )
		{
			String token = cmd.nextToken();

			if ( Atom.isValidID(token) )
			{
				if ( data.getAtom ( token ) == null )
					createDummy( token, lineTag );
			}
			else
				err.println ( "WARNING: "
							  + lineTag
							  + " invalid atom name in #import: \""
							  + token + "\"" );
		}
	}

	//-------------------------------------------------------------

	/**
	 *  Execute the "!noun" command. The nouns defined on
	 *  a particular atom are stored (as a list) in a property
	 *  called "__nouns__" (the trailing "__" is just in case
	 *  anyone defines a property called "nouns"). In addition,
	 *  a table of all nouns is kept, matching them to the
	 *  atoms that define them, and this can optionally be
	 *  exported to "nouns.html".
	 */
	protected void doNoun ( StringTokenizer cmd,
							String lineTag )
	{
		// extract args
		if ( ! cmd.hasMoreTokens() )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " no arguments to !NOUN" );
			return;
		}

		String pattern = cmd.nextToken();

		if ( !cmd.hasMoreTokens() )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " no atom provided for !NOUN" );
			return;
		}

		String atomID = cmd.nextToken();

		if ( cmd.hasMoreTokens() )
		{
			err.println ( "WARNING: "
						  + lineTag
						  + " too many arguments to !NOUN" );
		}

		// get the atom
		Atom atom = data.getAtom(atomID);

		if ( atom == null )
		{
			err.println( "WARNING: "
						 + lineTag
						 + " creating dummy for non-existent atom "
						 + atomID
						 + " specified to !NOUN" );
			atom = createDummy ( atomID, lineTag );
		}

		// find (or create) its __nouns__ property
		Object obj = atom.getField("__nouns__");
		Vector nounList;

		if ( obj == null )
		{
			nounList = new Vector ();
			atom.setField ( "__nouns__", nounList );
		}
		else if ( ! ( obj instanceof Vector ) )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " __nouns__ property of atom "
						  + atomID
						  + " is not a Vector" );
			return;
		}
		else
			nounList = (Vector) obj;

		// parse the pattern into its component words
		StringTokenizer tokenizer = new StringTokenizer ( pattern, ",;" );

		// we already know that the words will contain no whitespace,
		// commas or semicolons -- beyond that we don't care -- nouns
		// are not subject to the naming restrictions of atoms
		while ( tokenizer.hasMoreTokens() )
		{
			String token = tokenizer.nextToken();
			nounList.addElement ( token );
			nouns.put ( token, atomID );
		}

	}

	//-------------------------------------------------------------

	/**
	 *  Create a dummy atom in the database with the given
	 *  name. The dummy atom will inherit from the root atom.
	 */
	protected Atom createDummy ( String name,
								 String lineTag )
	{
		return createDummy ( name, null, lineTag );
	}

	//-------------------------------------------------------------

	/**
	 *  Create a dummy atom in the database inheriting from
	 *  the specified parent. If the parentName is <tt>null</tt>,
	 *  or not in the database, the dummy will inherit from the
	 *  root atom.
	 */
	protected Atom createDummy ( String name,
								 String parentName,
								 String lineTag )
	{
		// can't create a dummy if the atom already exists
		Atom dummy = data.getAtom( name );
		if ( dummy != null )
			return dummy;

		// get the parent
		Atom parent = null;

		if ( parentName != null )
			parent = data.getAtom( parentName );

		if ( parent == null )
			parent = data.getRoot();

		// create the atom
		dummy = data.newAtom ( name, parent );

		// set its dummy property
		dummy.setField ( "__", "dummy " + lineTag );

		return dummy;
	}

	//-------------------------------------------------------------
	//  writing
	//-------------------------------------------------------------

	/**
	 *  Export the documentation on the given atom to
	 *  an HTML file. This a really ugly monolithic function
	 *  that should ideally be delegated.
	 */
	public void writeDocs ( Atom atom )
	{
		// check that the atom is documentable
		String origin = (String) atom.getField("__");

		if ( origin != null && origin.startsWith ( "dummy" ) )
		{
			err.println( "NOTE: No documentation produced for dummy atom "
						 + atom.getID() );
			return;
		}

		String outName = outputPrefix + atom.getID() + ".html";

		// remove the path from the outputPrefix, if any,
		// for inter-document links
		String localPrefix;
		if ( outputPrefix.indexOf( File.separatorChar ) != -1 )
		{
			if ( outputPrefix.lastIndexOf ( File.separatorChar ) + 1 < outputPrefix.length() )
				localPrefix = outputPrefix.substring( outputPrefix.lastIndexOf( File.separatorChar ) );
			else
				localPrefix = "";
		}
		else
		{
			localPrefix = outputPrefix;
		}

		try
		{
			PrintWriter out = new PrintWriter ( new FileWriter( outName ), true );

			// ideally the file format would be taken from some
			// kind of template, but to start with let's just
			// hard-code it

			// header
			out.println ( "<html>" );
			out.println ( "<!-- Auto-generated by DocCompiler"
						  + new Date()
						  + "-->" );
			out.println ( "<head>" );
			out.println ( "<title>Documentation for "
						  + atom.getID()
						  + "</title>" );
			out.println ( "</head>" );

			// body
			out.println ( "<body bgcolor=white>" );
			out.println ( "<a name=\"__top__\"></a>" );
			out.println ( "<h1>" + atom.getID() + "</h1>" );

			// static type
			out.println ( "<b>Static (Java) type:</b>" );

	        if (atom.isDescendantOf(data.getAtom(AtomDatabase.MOBILE_ID)))
	            out.println ( "Mobile" );
	        else if (atom.isDescendantOf(data.getAtom(AtomDatabase.ROOM_ID)))
	            out.println ( "Room" );
	        else if (atom.isDescendantOf(data.getAtom(AtomDatabase.CONTAINER_ID)))
	            out.println ( "Container" );
	        else if (atom.isDescendantOf(data.getAtom(AtomDatabase.THING_ID)))
	            out.println ( "Thing" );
	        else
	        	out.println ( "Atom" );

			out.println ( "<p>" );

			// inheritance
			out.println ( "<b>Parents:</b>" );
			out.println ( "<ul>" );

			Enumeration parents = atom.getParents();
			while ( parents.hasMoreElements() )
			{
				// assume that there is a doc file for the parent
				// that we can link to
				Atom parent = (Atom) parents.nextElement();
				out.println ( "<li><a href=\""
							  + localPrefix + parent.getID() + ".html"
							  + "\">"
							  + parent.getID()
							  + "</a></li>" );
			}

			out.println ( "</ul>" );
			out.println ( "<p>" );

			if ( atom.hasChildren() )
			{
				out.println ( "<b>Children:</b>" );
				out.println ( "<ul>" );

				Enumeration children = atom.getChildren();
				while ( children.hasMoreElements() )
				{
					// assume that there is a doc file for the child
					Atom child = (Atom) children.nextElement();
					out.println ( "<li><a href=\""
								  + localPrefix + child.getID() + ".html"
								  + "\">"
								  + child.getID()
								  + "</a></li>" );
				}

				out.println ( "</ul>" );
				out.println ( "<p>" );
			}

			// nouns
			Object nounList = atom.getField ( "__nouns__" );

			if ( nounList != null
				 && nounList instanceof Vector
				 && ((Vector)nounList).size() > 0 )
			{
				out.println ( "<b>Nouns:</b>" );
				out.println ( "<ul>" );

				Enumeration theNouns = ((Vector)nounList).elements();
				while ( theNouns.hasMoreElements() )
				{
					out.println ( "<li>"
								  + theNouns.nextElement()
								  + "</li>" );
				}

				out.println ( "</ul>" );
				out.println ( "<p>" );
			}

			// source file
			out.println ( "<b>Source file:</b>" );
			if ( origin == null )
				out.println ( "Unknown" );
			else
				out.println ( origin );
			out.println ( "<p>" );

			// general comments
			String comments = (String) atom.getField( "__" + atom.getID() );
			if ( comments != null )
				out.println ( comments );

			out.println ( "<p>" );
			out.println ( "<hr>" );

			// fields

			// we keep a list of local field names so that we
			// can distinguish them from inherited ones
			Vector localFields = new Vector();

			out.println ( "<h2>Properties explicitly defined by "
						  + atom.getID()
						  + "</h2>" );

			out.println ( "<dl>" );

			Enumeration fieldNames = atom.getFieldNames();
			while ( fieldNames.hasMoreElements() )
			{
				String fieldName = ((String) fieldNames.nextElement()).intern();

				// skip documentation fields
				if ( fieldName.startsWith("__") )
					continue;

				localFields.addElement ( fieldName );

				out.println ( "<dt>" );

				out.println ( "<font size=+1 color=teal><b>&#149; "
						 	  + fieldName
						 	  + "</b></font><br>" );

				out.println ( "<dd>" );

				Object fieldValue = atom.getField( fieldName );
				String fieldType;

				switch ( AtomData.getFieldType( fieldValue ))
				{
					case AtomData.ATOM:
						fieldType = "Atom"; break;
					case AtomData.STRING:
						fieldType = "String"; break;
					case AtomData.INTEGER:
						fieldType = "Integer"; break;
					case AtomData.BOOLEAN:
						fieldType = "Boolean"; break;
					case AtomData.LIST:
						fieldType = "List"; break;
					case AtomData.TABLE:
						fieldType = "Table"; break;
					case AtomData.ACTION:
						fieldType = "Action"; break;
					case AtomData.NULL:
						fieldType = "Null"; break;

					case AtomData.UNKNOWN:
					default:
						fieldType = "Unknown";
				}

				out.println ( "<b>Type:</b> "
							  + fieldType
							  + "<br>" );

				// printing the value may be a mistake, since it could contain
				// characters that will fuck up the HTML -- should add some
				// detox process later
				out.println ( "<b>Value:</b>" );
				// Actions have to be treated specially, because they don't
				// really exist
				if ( fieldType.equals("Action") )
					out.println ( "!" + fieldValue.toString() );
				else
					out.println ( AtomData.toString( fieldValue ) );

				out.println ( "<br>" );


				// get property comments, if any
				comments = (String) atom.getRawProperty ( "__" + fieldName );

				if ( comments != null )
					out.println ( comments );

				out.println ( "<p>" );
			}

			out.println ( "</dl>" );

			out.println ( "<hr>" );

			// properties inherited from ancestors
			out.println ( "<h2>Inherited properties</h2>" );

			out.println ( "<dl>" );

			// we go through a similar palaver here, only worse...
			Hashtable properties = new Hashtable();
			atom.getProperties( properties );
			fieldNames = properties.keys();

			while ( fieldNames.hasMoreElements() )
			{
				String fieldName = ((String) fieldNames.nextElement()).intern();

				// skip documentation fields AND local fields
				if ( fieldName.startsWith("__") || localFields.contains( fieldName ) )
					continue;

				localFields.addElement ( fieldName );

				out.println ( "<dt>" );

				out.println ( "<font size=+1 color=purple><b>&#149; "
						 	  + fieldName
						 	  + "</b></font><br>" );

				out.println ( "<dd>" );

				Object fieldValue = properties.get( fieldName );
				String fieldType;

				switch ( AtomData.getFieldType( fieldValue ))
				{
					case AtomData.ATOM:
						fieldType = "Atom"; break;
					case AtomData.STRING:
						fieldType = "String"; break;
					case AtomData.INTEGER:
						fieldType = "Integer"; break;
					case AtomData.BOOLEAN:
						fieldType = "Boolean"; break;
					case AtomData.LIST:
						fieldType = "List"; break;
					case AtomData.TABLE:
						fieldType = "Table"; break;
					case AtomData.ACTION:
						fieldType = "Action"; break;
					case AtomData.NULL:
						fieldType = "Null"; break;

					case AtomData.UNKNOWN:
					default:
						fieldType = "Unknown";
				}

				out.println ( "<b>Type:</b> "
							  + fieldType
							  + "<br>" );

				// printing the value may be a mistake, since it could contain
				// characters that will fuck up the HTML -- should add some
				// detox process later
				out.println ( "<b>Value:</b>" );
				// Actions have to be treated specially, because they don't
				// really exist
				if ( fieldType.equals("Action") )
					out.println ( "!" + fieldValue.toString() );
				else
					out.println ( AtomData.toString( fieldValue ) );

				out.println ( "<br>" );


				// get property comments, if any
				comments = (String) properties.get ( "__" + fieldName );

				if ( comments != null )
					out.println ( comments );

				out.println ( "<p>" );
			}

			out.println ( "</dl>" );

			out.println ( "<hr>" );

			// footer
			out.println ( "<i>Copyright &copy; 1998 Ogalala Ltd</i>" );
			out.println ( "</body>" );
			out.println ( "</html>" );

			out.flush();
			out.close();
		}
		catch ( IOException e )
		{
			err.println ( "ERROR: exception writing file "
						  + outName
						  + ": " + e );
		}
	}

	//-------------------------------------------------------------

	/**
	 *  Export the documentation on a named atom to
	 *  an HTML file.
	 */
	public void writeDocs ( String atomName )
	{
		Atom atom = data.getAtom ( atomName );
		if ( atom == null )
			err.println ( "ERROR: can't document non-existent atom: "
						  + atomName );
		else
			writeDocs ( atom );
	}

	//-------------------------------------------------------------

	/**
	 *  Export the documentation on all the atoms in the
	 *  database (except any dummies) to a collection of
	 *  HTML files.
	 */
	public void writeAllDocs ()
	{
		Enumeration atoms = data.getAtoms();

		while ( atoms.hasMoreElements() )
			writeDocs ( (Atom) atoms.nextElement() );
	}

	//-------------------------------------------------------------

	/**
	 *  Export the nouns table to the file specified in
	 *  the <tt>nounFile</tt> property. If this is <tt>null</tt>,
	 *  no noun file is produced.
	 */
	public void writeNouns ()
	{
		if ( nounFile == null )
			return;

		String outName = outputPrefix + nounFile + ".html";

		// remove the path from the outputPrefix, if any,
		// for inter-document links
		String localPrefix;
		if ( outputPrefix.indexOf( File.separatorChar ) != -1 )
		{
			if ( outputPrefix.lastIndexOf ( File.separatorChar ) + 1 < outputPrefix.length() )
				localPrefix = outputPrefix.substring( outputPrefix.lastIndexOf( File.separatorChar ) );
			else
				localPrefix = "";
		}
		else
		{
			localPrefix = outputPrefix;
		}

		try
		{
			PrintWriter out = new PrintWriter ( new FileWriter( outName ), true );

			// this is a lot simpler than the other one,
			// basically just a list of links

			// header
			out.println ( "<html>" );
			out.println ( "<!-- Auto-generated by DocCompiler"
						  + new Date()
						  + "-->" );
			out.println ( "<head>" );
			out.println ( "<title>Nouns</title>" );
			out.println ( "</head>" );

			// body
			out.println ( "<body bgcolor=white>" );
			out.println ( "<a name=\"__top__\"></a>" );
			out.println ( "<h1>Nouns</h1>" );

			// nouns
			out.println ( "The following list details which atoms define each noun." );

			// this would probably be better done as a table,
			// but for the moment I'm doing it as a list 'cos it's easier
			out.println ( "<ul>" );

			// at present, the nouns are just listed in the order they
			// come out of the Hashtable, which might as well be random
			// in future I'll add something to pre-sort them into
			// alphabetical order, but as always that's a job for another day
			Enumeration nounNames = nouns.keys();
			while ( nounNames.hasMoreElements() )
			{
				// assume that there is a doc file for the atom
				// that we can link to
				String name = (String) nounNames.nextElement();
				String atom = (String) nouns.get( name );
				out.println ( "<li><b>"
							  + name
							  + "</b> : <a href=\""
							  + localPrefix + atom + ".html"
							  + "\">"
							  + atom
							  + "</a></li>" );
			}

			out.println ( "</ul>" );
			out.println ( "<p>" );


			out.println ( "<hr>" );

			// footer
			out.println ( "<i>Copyright &copy; 1998 Ogalala Ltd</i>" );
			out.println ( "</body>" );
			out.println ( "</html>" );

			out.flush();
			out.close();
		}
		catch ( IOException e )
		{
			err.println ( "ERROR: exception writing file "
						  + outName
						  + ": " + e );
		}
	}

	//-------------------------------------------------------------
	//  utils
	//-------------------------------------------------------------

	/**
	 *  Print a usage message for this application to
	 *  <tt>System.err</tt>.
	 */
	public void printUsage ()
	{
		System.err.println("DocCompiler usage:");
		System.err.println("java com.ogalala.tools.DocCompiler [options [args]]");
		System.err.println("  options:");
		System.err.println("  -e logFile        write errors to logFile");
		System.err.println("                    (default is System.err)");
		System.err.println("  -p prefix         add prefix to output file names" );
		System.err.println("  -m mapFile        write dependencies to mapFile" );
		System.err.println("                    (default is dependency.map)" );
		System.err.println("  -d dataBase       use the specified database file" );
		System.err.println("  -s scriptPath     search for scriptPath for script files");
		System.err.println("  -a atoms ...      output docs for the specified atoms" );
		System.err.println("                    (default is all atoms)" );
		System.err.println("  -f files ...      read atom definitions from the" );
		System.err.println("                    specified scripts" );
		System.err.println("  -n nounFile       output noun list to nounFile" );
		System.err.println("                    (adding prefix and .html suffix)" );
		System.err.println("  -h | --help | -?  print this usage message");
	}

	//-------------------------------------------------------------
}
