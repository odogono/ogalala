// $Id: DocCompiler.java,v 1.24 1999/03/17 16:39:39 matt Exp $
// Compiler to generate documentation files.
// Matthew Caldwell, 8 October 1998
// Copyright (c) Ogalala Limited <info@ogalala.com>

package com.ogalala.tools;

import com.ogalala.util.*;
import com.ogalala.mua.*;
import java.util.*;
import java.io.*;

/**
 *  The doc compiler reads an optional database file and
 *  any number of script files and produces documentation
 *  for some or all of the atoms defined therein. The
 *  documentation consists of inheritance information,
 *  properties and their values, and any documentation
 *  comments (those that start "##") defined for the atoms
 *  or their properties in the scripts.
 *  <p>
 *  By default, the compiler uses a temporary database,
 *  which is deleted when the compilation completes,
 *  but it can use an existing database or generate a
 *  new one. Note that a database file will only contain
 *  comments if it was created by a tool that supports them,
 *  such as this compiler.
 *  <p>
 *  If an existing database is used, any script files processed
 *  at the same time will be added to the database permanently.
 *  If in doubt, operate on a copy!
 *  <p>
 *  This compiler is more forgiving of script dependencies than
 *  the game itself, provided that scripts have correct #import
 *  directives (eg, as generated by the ODLCompiler). Dependencies
 *  which are not satisfied in the database at the time a file
 *  is processed are created as empty atoms, and then replaced
 *  later if an explicit creation command is encountered. This
 *  should mean that script subsets can be documented without
 *  having to recompile the whole world, but it may result in
 *  incorrectly empty ancestors for some atoms, and particularly
 *  may cause problems if the same database file is to be used
 *  with other tools. As an additional consequence, successful
 *  processing by this tool does not imply that a script will
 *  work in the game itself!
 *  <p>
 */
public class DocCompiler
	implements Runnable
{
	//-------------------------------------------------------------
	//  instance variables
	//-------------------------------------------------------------

	/**
	 *  The thread with which the <tt>run()</tt> method is
	 *  executed when the class is run as an application.
	 */
	protected Thread runThread = null;
	
	/**
	 *  The list of script files to be processed, as provided
	 *  on the command line. 
	 */
	protected Vector sources = null;
	
	/**
	 *  The list of specific atoms to be documented. If this is
	 *  <tt>null</tt>, the compiler outputs documentation for
	 *  the entire atom database.
	 */
	protected Vector atoms = null;
	
	/**
	 *  The name of an atom database file into which the
	 *  imported atoms should be inserted. If this is not
	 *  provided, a temporary database called
	 *  <tt>scratch_db.atom</tt> will be generated, and then
	 *  deleted once the compilation finishes.
	 */
	protected String dbName = DEFAULT_DB;
	
	/**
	 *  A string to be prefixed to all output filenames. By
	 *  default, output files are called <i>name</i><tt>.html</tt>,
	 *  where <i>name</i> is the name of the atom that the file
	 *  documents. If an output prefix is provided, output files
	 *  will be called <i><b>prefix</b>name</i><tt>.html</tt>.
	 *  On most systems the prefix may be a pathname, in which
	 *  case the files will be created in the appropriate path.
	 *  Note, however, that the directory structure must already
	 *  exist -- the program will probably throw an exception if
	 *  the prefix points to a non-existent directory.
	 */
	protected String outputPrefix = "".intern();

	/**
	 *  A stream to which error messages are written. This will
	 *  commonly be System.err (or a PrintWriter wrapper for it),
	 *  but can optionally be a log file.
	 */
	protected PrintWriter err = null;
	
	/**
	 *  A flag indicating whether the error file needs to be
	 *  closed before the program exits. If System.err is
	 *  being used, the program should not close the file itself.
	 */
	protected boolean closeErrFile = false;
	
	/**
	 *  A dummy game world used as a wrapper for AtomDatabase.
	 */
	protected World world = null;
	
	/**
	 *  The atom database that maintains the inheritance
	 *  relationships of all processed atoms.
	 */
	protected AtomDatabase data = null;
	
	/**
	 *  The current container assigned to things when they
	 *  are created.
	 */
	protected Container where = null;
		
	/**
	 *  A list of the currently running script files. This
	 *  is used to preempt mutually recursive "!run" commands.
	 */
	protected Vector openFiles = new Vector ();
	
	/**
	 *  The name of a file into which a dependency script
	 *  should be generated.
	 */
	protected String mapFile = DEFAULT_MAP_FILE;
	
	/**
	 *  Path to search for scripts. By default only the current
	 *  directory is searched. This may be changed with the
	 *  -s command line option.
	 */
	protected String scriptPath = ".";
	
	/**
	 *  Whether to include documentation for Things as well as
	 *  the abstract Atoms.
	 */
	protected boolean includeThings = true;
	
	/**
	 *  Whether to write documentation files at all. In some cases
	 *  it may be useful to run the whole process without actually
	 *  writing the files. This implements the '-z' command-line flag.
	 */
	protected boolean suppressOutput = false;
	
	/**
	 *  The output formatting object that actually writes the
	 *  documentation. At present only the HTMLAtomFormatter is
	 *  available, though there may be others eventually.
	 */
	protected AtomFormatter formatter = new HTMLAtomFormatter ();
	
	/**
	 *  Whether the atoms defined in the current file can be
	 *  modified by the tools. This is modified by the #final
	 *  ODL/script directive.
	 */
	protected boolean mutable = true;
	
	/**
	 *  The name of the ODL file from which the currently
	 *  executing script was compiled. This depends on the
	 *  #source script directive generated by the ODLCompiler.
	 *  If no #source directive is present, this will be
	 *  <tt>null</tt>.
	 *  <p>
	 *  Atoms created by the current script file have their
	 *  <tt>odl</tt> field set to this value so that the tools
	 *  can keep track of whence they came.
	 */
	protected String odl = null;
	
	/**
	 *  The admin atom of the world being documented. This is
	 *  used when executing unknown commands.
	 */
	protected Atom admin = null;
	
	/**
	 *  A parser for use when executing unknown commands.
	 */
	protected Parser parser = null;
	
	//-------------------------------------------------------------
	//  class variables
	//-------------------------------------------------------------
	
	/**
	 *  A reference to the application object if the class
	 *  is being run as an application. This is instantiated
	 *  by <tt>main()</tt>.
	 */
	protected static DocCompiler theApp = null;
	
	/**
	 *  The name of the atom database file that is created if no
	 *  database is specified on the command line.
	 */
	protected static final String DEFAULT_DB = "scratch.db".intern();
	
	/**
	 *  The name of a file to which any script file dependencies
	 *  should be written if none are specified.
	 */
	protected static final String DEFAULT_MAP_FILE = "dependency.map";
	
	/** Version string. */
	public static final String VERSION = "$Revision: 1.24 $";
	
	//-------------------------------------------------------------
	//  construction
	//-------------------------------------------------------------
	
	/**
	 *  The default constructor does nothing, on the assumption
	 *  that any initialization will be done by <tt>init()</tt>.
	 *  If the class is to be instantiated other than via the
	 *  standard invocation of <tt>main()</tt>, it may be
	 *  useful to provide other constructors.
	 */
	public DocCompiler ()
	{
	}

	//-------------------------------------------------------------
	//  application shell
	//-------------------------------------------------------------
	
	/**
	 *  Create an object of the compiler class and run it.
	 */
	public static void main ( String[] args )
	{
		theApp = new DocCompiler();
		
		// initialize and run
		if ( theApp.init(args) )
		{	
			theApp.runThread = new Thread ( theApp );
			theApp.runThread.start();
		}
	}

	//-------------------------------------------------------------
	
	/**
	 *  Do any necessary initialization from the command-line
	 *  arguments.
	 
	 @return  Whether the app successfully initialized.
	 
	 */
	public boolean init ( String[] args )
	{
		// nothing comes of nothing
		if ( args.length == 0 )
		{
			printUsage();
			return false;
		}
		
		// process command-line options
		int argPtr = 0;
		String errName = null;
		
		while ( true )
		{
			// handle options
			if ( argPtr >= args.length )
				break;
			
			// -h: help	
			if ( "-h".equals(args[argPtr])
				 || "--help".equals(args[argPtr])
				 || "-?".equals(args[argPtr]) )
			{
				printUsage();
				argPtr++;
			}
			// -t: omit Things
			else if ( "-t".equals(args[argPtr]) )
			{
				includeThings = false;
				argPtr++;
			}
			// -p: prefix
			else if ( "-p".equals(args[argPtr]) )
			{
				if ( argPtr + 1 < args.length )
				{
					outputPrefix = args[argPtr + 1];
					argPtr += 2;
				}
				else
				{
					System.err.println ( "ERROR: option -p requires an argument" );
					return false;
				}
			}
			// -s: script path
			else if ( "-s".equals(args[argPtr]) )
			{
				if ( argPtr + 1 < args.length )
				{
					scriptPath = args[argPtr + 1];
					argPtr += 2;
				}
				else
				{
					System.err.println ( "ERROR: option -s requires an argument" );
					return false;
				}
			}
			// -e: error file
			else if ( "-e".equals(args[argPtr]) )
			{
				if ( argPtr + 1 < args.length )
				{
					errName = args[argPtr + 1];
					argPtr += 2;
				}
				else
				{
					System.err.println ( "ERROR: option -e requires an argument" );
					return false;
				}
			}
			// -m: dependency map file
			else if ( "-m".equals(args[argPtr]) )
			{
				if ( argPtr + 1 < args.length )
				{
					mapFile = args[argPtr + 1];
					argPtr += 2;
				}
				else
				{
					System.err.println ( "ERROR: option -m requires an argument" );
					return false;
				}
			}
			// -n: nounFile -- no longer supported, but
			// included so old scripts don't break
			else if ( "-n".equals(args[argPtr]) )
			{
				argPtr += 2;
			}
			// -d: database file
			else if ( "-d".equals(args[argPtr]) )
			{
				if ( argPtr + 1 < args.length )
				{
					dbName = args[argPtr + 1];
					argPtr += 2;
				}
				else
				{
					System.err.println ( "ERROR: option -d requires an argument" );
					return false;
				}
			}
			// -a: atoms -- can be empty to suppress all output
			else if ( "-a".equals(args[argPtr]) )
			{
				if ( argPtr + 1 < args.length )
				{
					if ( atoms == null )
						atoms = new Vector ();
					
					argPtr++;
					
					while ( argPtr < args.length && !args[argPtr].startsWith("-") )
					{
						atoms.addElement ( args[argPtr] );
						argPtr++;
					}
				}
			}
			// -f: files
			else if ( "-f".equals(args[argPtr]) )
			{
				if ( argPtr + 1 < args.length )
				{
					if ( sources == null )
						sources = new Vector ();
					
					argPtr++;
					
					while ( argPtr < args.length && !args[argPtr].startsWith("-") )
					{
						sources.addElement ( args[argPtr] );
						argPtr++;
					}
				}
				else
				{
					System.err.println ( "ERROR: option -f requires one or more arguments" );
					return false;
				}
			}
			// -z: suppress all output
			else if ( "-z".equals(args[argPtr]) )
			{
				suppressOutput = true;
				argPtr++;
			}
			// unknown arguments
			else
			{
				System.err.println ( "ERROR: Unknown option: " + args[argPtr] );
				printUsage();
				return false;
			}
		}
		
		// there must be some atoms to document, either from script
		// files or an existing database -- if neither, there's nothing
		// to be done, so just warn and exit
		if ( sources == null && dbName == DEFAULT_DB )
		{
			System.err.println ( "WARNING: nothing to be documented." );
			return false;
		}
		
		// create the error file, if any
		try
		{
			if ( errName == null )
			{
				err = new PrintWriter ( System.out, true );
				closeErrFile = false;
			}
			else
			{
				err = new PrintWriter ( new FileWriter ( errName ), true );
			
				// since we opened the file, we must remember to close it
				closeErrFile = true;
			}
		}
		catch ( IOException e )
		{
			System.err.println ( "WARNING: Unable to create error file " + errName + ": " + e );
			System.err.println ( "Errors will be written to System.out" );
			err = new PrintWriter ( System.out );
			closeErrFile = false;
		}
		
		// attempt to create the world and get the database
		try
		{
			world = WorldFactory.newWorld ( dbName, scriptPath );
			data = world.getAtomDatabase ();
			where = (Container) data.getLimbo();
			
			// get the admin atom and a parser for it
			admin = world.getAtom ( world.ADMIN_ID );
			parser = world.newParser ();
		}
		catch ( IOException e )
		{
			// it's arguable that this should be written to err, but
			// I'd say all initialization errors get written together
			System.err.println ( "ERROR: Unable to open database file " + dbName + ": " + e );
			return false;
		}
		catch ( WorldException e )
		{
			System.err.println ( "ERROR: Unable to open world " + dbName + ": " + e );
			return false;
		}
		
		// initialize the output formatter objects
		formatter.init ( world, outputPrefix, err );
		
		// initialization succeeded
		return true;
	}
		
	//-------------------------------------------------------------

	/**
	 *  The main application procedure. When this exits, the
	 *  initial thread will end. The application itself may
	 *  continue, however, if other threads have been started
	 *  (notably the AWT event handling thread).
	 */
	public void run ()
	{
		// read any additional scripts and modify the
		// database accordingly
		if ( sources != null && sources.size() > 0 )
		{
			// if the source list contains only 1 file we
			// don't have to worry about dependencies
			if ( sources.size() == 1 )
			{
				readScript ( (String) sources.elementAt(0), null );
			}
			else
			{
				// we must first invoke the dependency compiler
				// and then run the dependency script
				
				// create the dependency compiler arg list
				String[] args = new String [ sources.size() + 2 ];
				args[0] = "-o";
				args[1] = mapFile;
				
				for ( int i = 0; i < sources.size(); i++ )
					args[i+2] = (String) sources.elementAt(i);
				
				DependencyCompiler dep = new DependencyCompiler();
				dep.setErr(err);
				dep.init(args);
				dep.run();
				
				// if compilation failed, we can't go on
				if ( ! dep.succeeded )
				{
					err.println ( "ERROR: dependency failure -- compilation aborted" );
					return;
				}
				
				// run the dependency script
				readScript ( mapFile, null );
			}
		}
		
		// output the documentation for the specified atoms
		if ( !suppressOutput )
		{
			if ( atoms == null )
			{
				writeAllDocs ();
			}
			else
			{
				Enumeration enum = atoms.elements();
				while ( enum.hasMoreElements() )
					writeDocs ( (String) enum.nextElement() );
			}
			
			// export the nouns table
			writeNouns();
			
			// export the index file
			writeIndex();
		}
		
		// if we're using a temporary database, delete it
		if ( dbName == DEFAULT_DB )
		{
			File dataFile = new File ( DEFAULT_DB );
			dataFile.delete();
		}
		// otherwise, save the changes
		else
		{
			try { WorldFactory.saveWorld( world ); }
			catch ( IOException e )
			{
				err.println ( "WARNING: Exception thrown when closing database: " + e );
			}
		}
		
		// close the error log file if necessary
		if ( closeErrFile )
		{
			err.flush();
			err.close();
		}
	}
		
	//-------------------------------------------------------------
	//  reading
	//-------------------------------------------------------------

	/**
	 *  Read a script and parse its contents into the atom
	 *  database. The script file is processed one line at
	 *  a time and each command dispatched to the relevant
	 *  handler. Plain comments are discarded, documentation
	 *  comments are accumulated and supplied to the
	 *  relevant command handler.
	 *  <p>
	 *  This method may be called recursively, so all cumulative
	 *  values are kept as local variables on the stack.
	 *  <p>
	 *  Errors encountered when reading files or executing
	 *  the commands they contain are written to <tt>err</tt>,
	 *  but don't abort the compilation process.
	 
	 @param fileName     The name of the script file to be run.
	 @param callingFile  The name of the file containing
	 */
	public void readScript ( String fileName,
							 String callingTag )
	{
		// files for !run are searched on the script path
		// they can't have any path of their own, so
		// remove any pathname supplied with the file
		File file = new File ( fileName );
		fileName = file.getName();
		
		int lineNumber = 0;
		String lineTag = "(" + fileName + ":" + lineNumber + ")";
		
		// locate the file on the filepath, if possible
		file = world.findFile( fileName );
		
		// note that the file is running so it can't
		// recursively run itself
		openFiles.addElement( file.getName().intern() );
		
		try
		{
			BufferedReader in = new BufferedReader ( new FileReader ( file ) );
			
			String comments = "";
			
			// files are assumed to be mutable until declared final
			mutable = true;
			
			// source is null until declared
			odl = null;
			
			while ( true )
			{
				String line = in.readLine();
				
				// exit the loop when we run out of input
				if ( line == null )
					break;
				
				line = line.trim();
				lineNumber++;
				
				// comment lines that start with 3 or more '#' characters
				// are discarded without another thought
				if ( line.startsWith("###") )
					continue;
				
				// append continuation lines (but not to comment lines)
				if ( ! line.startsWith("#") )
				{
					while ( line.endsWith("\\") )
					{
						String nextLine = in.readLine();
						
						// drop the trailing backslash
						line = line.substring( 0, line.length() - 1 );
						
						// append the next line, if any
						if ( nextLine != null )
						{
							line += nextLine.trim();
							lineNumber++;
						}
					}
				}
					
				// append doc comments to our current comment buildup
				if ( line.startsWith("##") )
				{
					comments += "\r\n" + line.substring( 2, line.length() ).trim();
				}
				// ignore empty lines
				else if ( line.equals("") )
				{
				}
				// tokenize everything else and despatch on the first token
				else
				{
					// update the line tag
					lineTag = "(" + fileName + ":" + lineNumber + ")";
					
					StringTokenizer tokenizer = new StringTokenizer ( line );
					
					String token = tokenizer.nextToken();
					
					// AtomExceptions may be thrown anywhere without
					// declaration, so make sure they're caught
					try
					{
						// despatch to the relevant handler and
						// reset comments if necessary
						if ( "#import".equalsIgnoreCase( token ) )
						{
							doImport ( tokenizer, lineTag );
						}
						else if ( "#final".equalsIgnoreCase( token ) )
						{
							// #final simply marks the file as
							// non-mutable, so no other handler
							// is necessary
							mutable = false;
						}
						else if ( "#source".equalsIgnoreCase( token ) )
						{
							doSource ( tokenizer, lineTag );
						}
						else if ( "!run".equalsIgnoreCase( token ) )
						{
							doRun ( tokenizer, lineTag );
						}
						else if ( "!atom".equalsIgnoreCase( token ) )
						{
							doAtom ( tokenizer, comments, lineTag );
							comments = "";
						}
						else if ( "!new".equalsIgnoreCase( token ) )
						{
							doNew ( tokenizer, comments, lineTag );
							comments = "";
						}
						else if ( "!go".equalsIgnoreCase( token ) )
						{
							doGo ( tokenizer, lineTag );
						}
						else if ( "!set".equalsIgnoreCase( token ) )
						{
							// set takes the line as well as the tokenizer
							// because it needs more complex access to the
							// args than StringTokenizer provides
							try
							{
								doSet ( tokenizer, line, comments, lineTag );
							}
							catch ( AtomException ex ) {}
							
							comments = "";
						}
						else if ( "!inherit".equalsIgnoreCase( token ) )
						{
							doInherit ( tokenizer, lineTag );
						}
						else if ( "!uninherit".equalsIgnoreCase( token ) )
						{
							doUninherit ( tokenizer, lineTag );
						}
						else if ( "!dig".equalsIgnoreCase( token ) )
						{
							doDig ( tokenizer, comments, lineTag );
							comments = "";
						}
						else if ( "!move".equalsIgnoreCase( token ) )
						{
							doMove ( tokenizer, lineTag );
						}
						else
						{
							tryRealCommand ( line, lineTag );
						}
					}
					catch ( AtomException x )
					{
						err.println ( "ERROR: "
									  + lineTag
									  + " exception thrown processing command: "
									  + x );
					}
				}
			}
		}
		catch ( IOException e )
		{
			if ( callingTag != null )
				err.println ( "ERROR: "
							  + lineTag
							  + "[run from "
							  + callingTag
							  + "] exception reading file: "
							  + e );
			else
				
				err.println ( "ERROR: "
							  + lineTag
							  + " exception reading file: "
							  + e );
		}
		
		// file is no longer running, so could conceivably be
		// run again -- may want to remove this so every script
		// can only be run once?
		openFiles.removeElement( file.getName().intern() );
	}

	//-------------------------------------------------------------

	/**
	 *  Run a script file. This is a recursive process that could
	 *  cause a stack overflow, but so be it. This method does
	 *  guard against looping, by keeping a list of all running
	 *  files and making sure that the new file is not in the
	 *  list before running it. The actual running is done
	 *  by the <tt>readScript()</tt> method.
	 */
	protected void doRun ( StringTokenizer cmd,
						   String lineTag )
	{
		// get the name of the file to be run
		if ( cmd.hasMoreTokens() )
		{
			// assumes we're using case-sensitive filenames,
			// which may be wrong, but scripts should be written
			// with this in mind, since the server will be
			// running on case-sensitive Unix (probably)
			String newFile = cmd.nextToken().intern();
			if ( openFiles.contains(newFile) )
			{
				err.println ( "ERROR: "
							  + lineTag
							  + " attempt to run already-running script "
							  + newFile );
			}
			else
			{
				// stack the current mutability and source, as
				// these are reset for each file
				boolean oldMutable = mutable;
				String oldODL = odl;
				
				try
				{
					readScript ( newFile, lineTag );
				}
				finally
				{
					mutable = oldMutable;
					odl = oldODL;
				}
			}
		}
		else
			err.println ( "WARNING: "
						  + lineTag
						  + " no filename supplied to !RUN" );
	}
	
	//-------------------------------------------------------------

	/**
	 *  Execute the "!new" command according to the supplied
	 *  command-line arguments. Create a new thing in the game
	 *  database, inheriting from the specified parents, and
	 *  associating the specified comments with it.
	 *  <p>
	 *  Thing comments are stored in a property whose name
	 *  is the thing's id prefixed with a double underscore.
	 *  <p>
	 *  As with the standard ModNewThing action, the parents are
	 *  sorted to create the correct static type. If no parents 
	 *  are specified, the new thing inherits from "thing".
	 *  <p>
	 *  For the purposes of this compiler, atoms (and things)
	 *  have a special property "__" which contains either
	 *  the value "dummy" (indicating that the atom is a fake
	 *  created to satisfy a declared dependency) or a string
	 *  containing the name of the file in which the atom was
	 *  created and the line number of the relevant "!atom"
	 *  or "!new" command. In cases of multiple definitions,
	 *  the second and subsequent creation commands fail and
	 *  report where the original creation occurred.
	 */
	protected void doNew ( StringTokenizer cmd,
						   String comments,
						   String lineTag )
	{
		if ( ! cmd.hasMoreElements() )
		{
			err.println( "ERROR: "
						 + lineTag
						 + " no thing ID supplied to !NEW" );
			return;
		}
		
		String thingID = (String) cmd.nextToken();
		
		Atom thing = data.getAtom(thingID);
		if ( thing != null )
		{
			String origin = (String) thing.getField("__");
			err.print( "ERROR: "
					   + lineTag
					   + " attempt to recreate thing \""
					   + thingID
					   + "\" " );
			
			if ( origin == null )
			{
				err.println ( "(original source unknown)" );
			}
			else if ( origin.startsWith("dummy") )
			{
				err.println ( "previously created as " + origin );
			}
			else
			{
				err.println ( "previously created at " + origin );
			}
			
			return;
		}
		
		// generate a sorted list of parents
		AtomVector parents = new AtomVector();
		
		while ( cmd.hasMoreElements() )
		{
			String parentID = (String) cmd.nextToken();
			Atom parent = data.getAtom ( parentID );
			if ( parent == null )
			{
				err.println( "WARNING: "
							 + lineTag
							 + " creating dummy for non-existent parent in !NEW: "
							 + parentID );
				parent = createDummy( parentID, lineTag );
			}
			
			parents.put ( parent );
		}
		
		parents.sort();
		
		// create the thing
		if ( parents.size() == 0 )
			thing = world.newThing ( thingID, data.getAtom(AtomDatabase.THING_ID) );
		else
			thing = world.newThing ( thingID, parents.get(parents.size() - 1) );
		
		// inherit from the other parents, in reverse order
		if ( parents.size() > 1 )
		{
			for ( int i = parents.size() - 2; i >= 0; i-- )
				thing.inherit(parents.get(i));
		}
		
		// move the thing to the current location (if it *is* a thing)
		if ( thing instanceof Thing && where != null )
			where.putIn(thing);
		
		// add the source field
		thing.setField( "__", lineTag );
		
		// add the source odl field
		if ( odl != null )
			thing.setField( "__odl__", odl );
		
		// if the current file is marked #final, this
		// atom must be given the __final__ field
		if ( !mutable )
			thing.setField("__final__", "final".intern() );
		
		// if there are any comments, add them
		if ( comments != null && comments.length() > 0 )
			thing.setField("__" + thingID, comments);
	}

	//-------------------------------------------------------------
	
	/**
	 *  Execute the "!atom" command according to the supplied
	 *  command-line arguments. Create a new atom in the game
	 *  database, inheriting from the specified parents and
	 *  associating the specified comments with it.
	 *  <p>
	 *  Atom comments are stored in a property whose name is
	 *  the atom's id prefixed with a double underscore.
	 *  <p>
	 *  For the purposes of this compiler, atoms (and things)
	 *  have a special property "__" which contains either
	 *  the value "dummy" (indicating that the atom is a fake
	 *  created to satisfy a declared dependency) or a string
	 *  containing the name of the file in which the atom was
	 *  created and the line number of the relevant "!atom"
	 *  or "!new" command. In cases of multiple definitions,
	 *  the second and subsequent creation commands fail and
	 *  report where the original creation occurred.
	 */
	protected void doAtom ( StringTokenizer cmd,
						    String comments,
						    String lineTag )
	{
		if ( ! cmd.hasMoreElements() )
		{
			err.println( "ERROR: "
						 + lineTag
						 + " no atom ID supplied to !ATOM" );
			return;
		}
		
		String atomID = (String) cmd.nextToken();
		
		Atom atom = data.getAtom(atomID);
		if ( atom != null )
		{
			String origin = (String) atom.getField("__");
			err.print( "ERROR: "
					   + lineTag
					   + " attempt to recreate atom \""
					   + atomID
					   + "\" " );
			
			if ( origin == null )
			{
				err.println ( "(original source unknown)" );
			}
			else if ( origin.equals("dummy") )
			{
				err.println ( "previously created as a dummy" );
			}
			else
			{
				err.println ( "previously created at " + origin );
			}
			
			return;
		}

		// generate a sorted list of parents
		AtomVector parents = new AtomVector();
		
		while ( cmd.hasMoreElements() )
		{
			String parentID = (String) cmd.nextToken();
			Atom parent = data.getAtom ( parentID );
			if ( parent == null )
			{
				err.println( "WARNING: "
							 + lineTag
							 + " creating dummy for non-existent parent in !ATOM: "
							 + parentID );
				parent = createDummy( parentID, lineTag );
			}
			
			parents.put ( parent );
		}
		
		parents.sort();
		
		// create the atom
		if ( parents.size() == 0 )
			atom = data.newAtom ( atomID, data.getRoot() );
		else
			atom = data.newAtom ( atomID, parents.get(parents.size() - 1) );
		
		// inherit from the other parents, in reverse order
		if ( parents.size() > 1 )
		{
			for ( int i = parents.size() - 2; i >= 0; i-- )
				atom.inherit(parents.get(i));
		}
		
		// add the source field
		atom.setField( "__", lineTag );
		
		// add the source ODL field
		if ( odl != null )
			atom.setField( "__odl__", odl );
		
		// if the current file is marked #final, this
		// atom must be given the __final__ field
		if ( !mutable )
			atom.setField("__final__", "final".intern() );
			
		// if there are any comments, add them
		if ( comments != null && comments.length() > 0 )
			atom.setField("__" + atomID, comments);
	}

	//-------------------------------------------------------------

	/**
	 *  Set the given property on an atom according to the
	 *  supplied command-line arguments, associating
	 *  the specified comments with it.
	 *  <p>
	 *  Property comments are stored in a property whose name
	 *  is the property name prefixed with a double underscore.
	 */
	protected void doSet ( StringTokenizer cmd,
						   String cmdLine,
						   String comments,
						   String lineTag )
	{
		if ( ! cmd.hasMoreTokens() )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " no arguments to !SET" );
			return;
		}
		
		// get the atom.field tag
		String atomField = cmd.nextToken();
		
		// the rest of the line is the value -- this will be wrong if
		// the atomField is a substring of !set, but that's an error
		// anyway
		String value = null;
		try
		{
			value = cmdLine.substring ( cmdLine.indexOf( atomField )
										+ atomField.length() ).trim();
		}
		catch ( IndexOutOfBoundsException e )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " no value supplied for !SET "
						  + atomField );
			return;
		}
		
		// split the atom.field tag into an atom ID and a field ID
		String atomID = null, fieldID = null;
		
		try
		{
			atomID = atomField.substring ( 0, atomField.indexOf('.') );
			fieldID = atomField.substring ( atomField.indexOf('.') + 1 );
		}
		catch ( IndexOutOfBoundsException e )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " invalid property specifier for !SET: \""
						  + atomField
						  + "\"" );
			return;
		}
					
		Atom atom = data.getAtom ( atomID );
		
		if ( atom == null )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " attempt to set property of non-existent atom: \""
						  + atomID
						  + "\"" );
			return;
		}
		
		// if atom is a container, we may be referring to an
		// exit in that container using the room.direction.field
		// syntax, so check for that
		if ( atom instanceof Container
			 && ( fieldID.indexOf(".") != -1 ) )
		{
			String dirSpec = fieldID.substring ( 0, fieldID.indexOf(".") );
			
			if ( fieldID.indexOf(".") + 1 >= fieldID.length() )
			{
				err.println ( "ERROR: "
							  + lineTag
							  + " invalid property specification: \""
							  + fieldID
							  + "\"" );
				return;
			}
			
			fieldID = fieldID.substring ( fieldID.indexOf(".") + 1 );
			
			int direction = ExitTable.toDirection ( dirSpec );
			if ( direction == 0 )
			{
				err.println ( "ERROR: "
							  + lineTag
							  + " invalid direction in property assignment: \""
							  + dirSpec
							  + "\"" );
				return;
			}
			
			atom = (Atom) ((Container) atom).getExit( direction );
			if ( atom == null )
			{
				err.println ( "ERROR: "
							  + lineTag
							  + " attempt to set property on non-existent exit "
							  + atomID + "." + dirSpec );
				return;
			}
		}
		
		// check that the field name is valid
		if ( ! Atom.isValidID ( fieldID ) )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " invalid property name: \""
						  + fieldID
						  + "\"" );
			return;
		}
		
		// set the value
		// parseField() doesn't strip surrounding quotes, so do that first
		value = StringUtil.stripQuotes ( value );
		
		atom.setField( fieldID, atom.parseField(value) );
		
		// set the value comments, if any
		if ( comments != null && comments.length() > 0 )
			atom.setField( "__" + fieldID, comments );
	}

	//-------------------------------------------------------------

	/**
	 *  Execute the "!inherit" command according to the
	 *  supplied command-line arguments. If either the
	 *  atom or the new parent does not exist in the atom
	 *  database, it is created as a dummy and a warning
	 *  is given.
	 */
	protected void doInherit ( StringTokenizer cmd,
							   String lineTag )
	{
		// extract args
		if ( ! cmd.hasMoreTokens() )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " no arguments to !INHERIT" );
			return;
		}
		
		String atomID = cmd.nextToken();
		
		if ( !cmd.hasMoreTokens() )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " no parent provided for !INHERIT" );
			return;
		}
		
		String parentID = cmd.nextToken();
		
		if ( cmd.hasMoreTokens() )
		{
			err.println ( "WARNING: "
						  + lineTag
						  + " too many arguments to !INHERIT" );
		}
		
		Atom parent = data.getAtom ( parentID );
		
		if ( parent == null )
		{
			err.println ( "WARNING: "
						  + lineTag
						  + " creating dummy for non-existent parent in !INHERIT: \""
						  + parentID
						  + "\"" );
			parent = createDummy ( parentID, lineTag );
		}
		
		Atom atom = data.getAtom ( atomID );
		
		if ( atom == null )
		{
			err.println ( "WARNING: "
						  + lineTag
						  + " creating dummy for non-existent child in !INHERIT: \""
						  + atomID
						  + "\"" );
			atom = data.newAtom ( atomID, parent );
			
			// mark the atom as a dummy
			atom.setField ( "__", "dummy " + lineTag );
			
			// already inherits from parent, so we can just return
			return;
		}
		
		atom.inherit(parent);
	}
	
	//-------------------------------------------------------------
	
	/**
	 *  Execute the "!uninherit" command according to the
	 *  supplied command-line arguments. If the atom does
	 *  not exist or does not have the specified parent,
	 *  a warning is emitted.
	 */
	protected void doUninherit ( StringTokenizer cmd,
								 String lineTag )
	{
		// extract args
		if ( ! cmd.hasMoreTokens() )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " no arguments to !UNINHERIT" );
			return;
		}
		
		String atomID = cmd.nextToken();
		
		if ( !cmd.hasMoreTokens() )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " no parent provided for !UNINHERIT" );
			return;
		}
		
		String parentID = cmd.nextToken();
		
		if ( cmd.hasMoreTokens() )
		{
			err.println ( "WARNING: "
						  + lineTag
						  + " too many arguments to !UNINHERIT" );
		}
		
		Atom parent = data.getAtom ( parentID );
		
		if ( parent == null )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " non-existent parent to !UNINHERIT: \""
						  + parentID
						  + "\"" );
			return;
		}
		
		Atom atom = data.getAtom ( atomID );
		
		if ( atom == null )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " non-existent child to !UNINHERIT: \""
						  + atomID
						  + "\"" );
			return;
		}
		
		atom.uninherit(parent);
	}

	//-------------------------------------------------------------

	/**
	 *  Execute the "!go" command according to the supplied
	 *  command-line arguments. If the specified location
	 *  does not exist it is created as a dummy and a warning
	 *  given. If it exists but is not a container, an error
	 *  results.
	 */
	protected void doGo ( StringTokenizer cmd,
						  String lineTag )
	{
		if ( ! cmd.hasMoreTokens() )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " no arguments to !GO" );
			return;
		}
		
		String whereID = cmd.nextToken();
		
		if ( cmd.hasMoreTokens() )
		{
			err.println ( "WARNING: "
						  + lineTag
						  + " too many arguments to !GO" );
		}
		
		Atom container = data.getAtom ( whereID );
		
		if ( container == null )
		{
			err.println ( "WARNING: "
						  + lineTag
						  + " creating non-existent !GO destination as a dummy: \""
						  + whereID
						  + "\"" );
			where = (Container) world.newThing ( whereID,
											     data.getAtom(AtomDatabase.CONTAINER_ID) );
			where.setField ( "__", "dummy " + lineTag );
		}
		else if ( container instanceof Container )
		{
			where = (Container) container;
		}
		else
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " !GO destination is not a container: \""
						  + whereID
						  + "\"" );
		}
		
	}

	//-------------------------------------------------------------

	/**
	 *  Execute the "!dig" command to create a conduit
	 *  between two containers. An exit object is created
	 *  and placed in each container, and the two exits
	 *  are linked together. Each exit is then mapped into
	 *  the respective container's exit table.
	 */
	protected void doDig ( StringTokenizer cmd,
						   String comments,
						   String lineTag )
	{
		err.println ( "LOG: entering doDig()" );
		
		// get the arguments
		if ( ! cmd.hasMoreTokens() )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " no arguments to !DIG" );
			return;
		}
		
		// direction specifier
		String dirSpec = cmd.nextToken();
		
		if ( ! cmd.hasMoreTokens() )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " too few arguments to !DIG" );
			return;
		}
		
		// source container
		String fromName = cmd.nextToken();
		
		if ( ! cmd.hasMoreTokens() )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " too few arguments to !DIG" );
			return;
		}
		
		// destination container
		String toName = cmd.nextToken();
		
		String fromClass = null;
		String toClass = null;

		// source exit class
		if ( cmd.hasMoreTokens() )
		{
			fromClass = cmd.nextToken();
		}
		
		// destination exit class
		if ( cmd.hasMoreTokens() )
		{
			toClass = cmd.nextToken();
		}
		
		if ( cmd.hasMoreTokens() )
		{
			err.println ( "WARNING: "
						  + lineTag
						  + " too many arguments to !DIG" );
		}
		
		// break the string into "from" and "to" parts and
		// parse each into direction flags
		StringTokenizer st = new StringTokenizer ( dirSpec, "-\"" );
		String fromSpec = st.nextToken();
		int fromDirection = parseDirection ( fromSpec );
		if ( fromDirection == -1 )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " !DIG invalid source direction "
						  + fromSpec );
			return;
		}
		
		boolean isOneWay = false;
		String toSpec = "";
		int toDirection = 0;
		
		if ( st.hasMoreTokens() )
		{
			toSpec = st.nextToken();
			if ( "none".equalsIgnoreCase(toSpec) )
				isOneWay = true;
			else
			{
				toDirection = parseDirection ( toSpec );
				if ( toDirection == -1 )
				{
					err.println ( "ERROR: "
								  + lineTag
								  + " !DIG invalid destination direction "
								  + toSpec );
					return;					
				}
			}
		}
		
		// get the 'from' container
		Atom fromContainer = world.getAtom ( fromName );
		if ( fromContainer == null )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " !DIG source container does not exist: "
						  + fromName );
			return;
		}
		
		// get the 'to' container
		Atom toContainer = world.getAtom ( toName );
		if ( toContainer == null )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " !DIG destination container does not exist: "
						  + toName );
			return;
		}
		
		// get the 'from' exit atom
		Atom fromExit;
		if ( fromClass != null )
		{
			fromExit = world.getAtom ( fromClass );
			if ( fromExit == null )
			{
				err.println ( "ERROR: "
							  + lineTag
							  + " !DIG exit template does not exist: "
							  + fromClass );
				return;
			}
		}
		else
			fromExit = world.getAtom("exit");
		
		// get the 'to' exit atom
		Atom toExit;
		if ( toClass != null )
		{
			toExit = world.getAtom ( toClass );
			if ( toExit == null )
			{
				err.println ( "ERROR: "
							  + lineTag
							  + " !DIG exit template does not exist: "
							  + toClass );
				return;
			}
		}
		else
			toExit = fromExit;
		
		// check if there are exits already defined in
		// any of the directions
		if ( fromContainer.getExit(fromDirection) != null )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " !DIG attempt to duplicate already existing exit: "
						  + fromName
						  + "."
						  + ExitTable.toString ( fromDirection ));
			return;
		}

		if ( !isOneWay
			 && ( toContainer.getExit(toDirection) != null ) )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " !DIG attempt to duplicate already existing exit: "
						  + toName
						  + "."
						  + ExitTable.toString ( toDirection ));
			return;
		}

		// create the exit Things
		String fromExitID = world.getUniqueID(fromExit.getID());
		fromExit = world.newThing(fromExitID, fromExit);
		String toExitID = "";
		if ( !isOneWay )
		{
			toExitID = world.getUniqueID(toExit.getID());
			toExit = world.newThing(toExitID, toExit);
		}
		
		// link the exits into the world
        if (isOneWay)
        {
            world.addExit ( fromDirection,
            				fromContainer,
            				fromExit,
            				toContainer);
        }
        else
        {
            if (toDirection == 0)
                toDirection = ExitTable.getOppositeDirection(fromDirection);
            world.addExit ( fromDirection,
            				fromContainer,
            				fromExit,
            				toDirection,
            				toContainer,
            				toExit);
        }
		
		// add the standard fields to the exit objects
		
		// source must exist
		fromExit.setField ( "__", lineTag );
		if ( odl != null )
			fromExit.setField ( "__odl__", odl );
		if ( !mutable )
			fromExit.setField("__final__", "final".intern() );
		
		// both exits get the comments, if any
		if ( comments != null && comments.length() > 0 )
			fromExit.setField( "__" + fromExit.getID(), comments );
		
		// destination exists either way
		if ( !isOneWay )
		{
			toExit.setField ( "__", lineTag );
			if ( odl != null )
				toExit.setField ( "__odl__", odl );
			if ( !mutable )
				toExit.setField("__final__", "final".intern() );
			
			// both exits get the comments, if any
			if ( comments != null && comments.length() > 0 )
				toExit.setField( "__" + toExit.getID(), comments );
		}
	}

	//-------------------------------------------------------------

	/**
	 *  Execute the "!move" command.
	 */
	protected void doMove ( StringTokenizer cmd,
						    String lineTag )
	{
		// read the args
		if ( ! cmd.hasMoreTokens() )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " no arguments to !MOVE" );
			return;
		}
		
		String whatID = cmd.nextToken();
		
		if ( ! cmd.hasMoreTokens() )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " not enough arguments to !MOVE" );
			return;
		}
		
		String dstID = cmd.nextToken();
		
		if ( cmd.hasMoreTokens() )
		{
			err.println ( "WARNING: "
						  + lineTag
						  + " too many arguments to !MOVE" );
		}
		
		// get relevant atoms
		Atom what = data.getAtom ( whatID );
		if ( what == null )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " !MOVE object does not exist: \""
						  + whatID
						  + "\"" );
			return;
		}
		else if ( ! (what instanceof Thing) )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " !MOVE object is not a Thing: \""
						  + whatID
						  + "\"" );
			return;
		}
		
		Atom dst = data.getAtom ( dstID );
		if ( dst == null )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " !MOVE destination does not exist: \""
						  + dstID
						  + "\"" );
			return;
		}
		else if ( ! (dst instanceof Container) )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " !MOVE destination is not a container: \""
						  + dstID
						  + "\"" );
			return;
		}
		
		// do the move
		((Container) dst).putIn ( what );
	}

	//-------------------------------------------------------------

	/**
	 *  Execute the "#import" script directive. The atom
	 *  database is checked to ensure it contains all the
	 *  specified atoms, and if it doesn't they are created
	 *  as descendants of the root atom.
	 *  <p>
	 *  Atoms that are created artificially here are
	 *  marked as such by the property "__", which has the
	 *  value "dummy". They may need to be replaced later
	 *  when the correct script actually creates them.
	 *  This is kind of painful, and still may not work,
	 *  see <tt>doAtom()</tt> and <tt>doNew()</tt> for
	 *  details.
	 */
	protected void doImport ( StringTokenizer cmd,
							  String lineTag )
	{
		while ( cmd.hasMoreTokens() )
		{
			String token = cmd.nextToken();
			
			if ( Atom.isValidID(token) )
			{
				if ( data.getAtom ( token ) == null )
					createDummy( token, lineTag );
			}
			else
				err.println ( "WARNING: "
							  + lineTag
							  + " invalid atom name in #import: \""
							  + token + "\"" );
		}
	}

	//-------------------------------------------------------------

	/**
	 *  Execute the "#source" script directive. This just
	 *  records the original ODL file the script was compiled
	 *  from, to be recorded on each atom so it can be tracked
	 *  by the tools.
	 */
	protected void doSource ( StringTokenizer cmd,
							  String lineTag )
	{
		if ( ! cmd.hasMoreTokens() )
		{
			err.println ( "ERROR: "
						  + lineTag
						  + " no file supplied in #source" );
			return;
		}
		else
			odl = cmd.nextToken();
	}

	//-------------------------------------------------------------

	/**
	 *  Commands that don't have a documentary implementation
	 *  here are submitted to the parser in case they have a
	 *  useful internal function.
	 */
	protected void tryRealCommand ( String line,
									String lineTag )
	{
		try
		{
			world.parseCommand ( line, admin, parser );
		}
		catch ( ParserException e )
		{					
			// warn about unknown commands
			err.println ( "ERROR: "
						  + lineTag
						  + " exception thrown when parsing command command: \""
						  + line
						  + "\":"
						  + e );
		}
	}
	
	//-------------------------------------------------------------

	/**
	 *  Create a dummy atom in the database with the given
	 *  name. The dummy atom will inherit from the root atom.
	 */
	protected Atom createDummy ( String name,
								 String lineTag )
	{
		return createDummy ( name, null, lineTag );
	}
	
	//-------------------------------------------------------------
	
	/**
	 *  Create a dummy atom in the database inheriting from
	 *  the specified parent. If the parentName is <tt>null</tt>,
	 *  or not in the database, the dummy will inherit from the
	 *  root atom.
	 */
	protected Atom createDummy ( String name,
								 String parentName,
								 String lineTag )
	{
		// can't create a dummy if the atom already exists
		Atom dummy = data.getAtom( name );
		if ( dummy != null )
			return dummy;
		
		// get the parent
		Atom parent = null;
		
		if ( parentName != null )
			parent = data.getAtom( parentName );
		
		if ( parent == null )
			parent = data.getRoot();
		
		// create the atom
		dummy = data.newAtom ( name, parent );
		
		// set its dummy property
		dummy.setField ( "__", "dummy " + lineTag );

		// if the current file is marked #final, this
		// atom must be given the __final__ field
		if ( !mutable )
			dummy.setField("__final__", "final".intern() );
		
		return dummy;
	}
		
	//-------------------------------------------------------------

	/**
	 *  Convert a direction specifier string into the
	 *  flags that the exit table uses. If the specifier
	 *  is invalid, this returns -1.
	 */
	protected int parseDirection ( String directionLabels )
	{
        int result = 0;
        StringTokenizer st = new StringTokenizer(directionLabels, ";,");
        while (st.hasMoreTokens())
        {
            String s = st.nextToken();
            int direction = ExitTable.toDirection(s);
            if (direction == 0)
                return -1;
            result |= direction;
        }
        return result;
	}	

	//-------------------------------------------------------------
	//  writing
	//-------------------------------------------------------------

	/**
	 *  Export the documentation on the given atom to
	 *  an HTML file.
	 */
	public void writeDocs ( Atom atom )
	{		
		// if not including things, we only document Atoms
		if ( !includeThings )
		{
			if ( ! "Atom".equals(atom.getClassName()) )
				return;
		}

		// delegate the actual writing to our formatter
		formatter.documentAtom ( atom );
	}
	
	//-------------------------------------------------------------

	/**
	 *  Export the documentation on a named atom to
	 *  an HTML file.
	 */
	public void writeDocs ( String atomName )
	{
		Atom atom = data.getAtom ( atomName );
		if ( atom == null )
			err.println ( "ERROR: can't document non-existent atom: "
						  + atomName );
		else
			writeDocs ( atom );
	}

	//-------------------------------------------------------------
	
	/**
	 *  Export the documentation on all the atoms in the
	 *  database (except any dummies) to a collection of
	 *  HTML files.
	 */
	public void writeAllDocs ()
	{
		Enumeration atoms = data.getAtoms();
		
		while ( atoms.hasMoreElements() )
			writeDocs ( (Atom) atoms.nextElement() );
	}

	//-------------------------------------------------------------
	
	/**
	 *  Export the nouns table.
	 */
	public void writeNouns ()
	{
		// generate a table mapping nouns to the names
		// of the atoms that define them
		Vocabulary vocab = world.getVocabulary();
		Hashtable nouns = new Hashtable();
		
		Enumeration enum = vocab.getNouns();
		while ( enum.hasMoreElements() )
		{
			String noun = (String) enum.nextElement();
			Atom atom = vocab.getNoun ( noun );
			
			if ( atom != null )
				nouns.put ( noun, atom.getID() );
		}
		
		// deliver this table to the formatter
		formatter.documentNouns ( nouns );
	}

	//-------------------------------------------------------------
	
	/**
	 *  Export the atom index.
	 */
	public void writeIndex ()
	{
		// delegate to the formatter
		formatter.indexAtoms( includeThings );
	}

	//-------------------------------------------------------------
	//  utils
	//-------------------------------------------------------------
		
	/**
	 *  Print a usage message for this application to
	 *  <tt>System.err</tt>.
	 */
	public void printUsage ()
	{
		System.err.println("DocCompiler [" + VERSION + "] usage:");
		System.err.println("java com.ogalala.tools.DocCompiler [options [args]]");
		System.err.println("  options:");
		System.err.println("  -e logFile        write errors to logFile");
		System.err.println("                    (default is System.err)");
		System.err.println("  -p prefix         add prefix to output file names" );
		System.err.println("  -m mapFile        write dependencies to mapFile" );
		System.err.println("                    (default is dependency.map)" );
		System.err.println("  -d dataBase       use the specified database file" );
		System.err.println("  -s scriptPath     search for scriptPath for script files");
		System.err.println("  -a atoms ...      output docs for the specified atoms" );
		System.err.println("                    (default is all atoms)" );
		System.err.println("  -f files ...      read atom definitions from the" );
		System.err.println("                    specified scripts" );
		System.err.println("  -n nounFile       *ignored (retained for compatibility)*");
		System.err.println("  -t                don't document things, only atoms" );
		System.err.println("  -z                don't produce any documentation files" );
		System.err.println("                    (overrides -a)" );
		System.err.println("  -h | --help | -?  print this usage message");
	}
	
	//-------------------------------------------------------------
}
