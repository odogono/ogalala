// $Id: ODLExporter.java,v 1.8 1999/03/11 10:41:10 alex Exp $
// A class to export atoms to ODL
// Matthew Caldwell, 1 February 1999
// Copyright (c) Ogalala Ltd <info@ogalala.com>

package com.ogalala.tools;

import java.util.*;
import java.io.*;

import com.ogalala.util.*;
import com.ogalala.mua.*;

/**
 *  A class to export a given collection of atoms to
 *  a given ODL file.
 */
public class ODLExporter
{
	//----------------------------------------------------------------
	//  instance variables
	//----------------------------------------------------------------

	/**
	 *  The stream to which the ODL should be written. This will
	 *  typically be opened by <tt>export()</tt>, but may also
	 *  be supplied explicitly.
	 */
	protected PrintWriter out = null;

	/**
	 *  A string containing property definitions that
	 *  have been deferred to the exits table because
	 *  they refer to atoms in the same file that have
	 *  not yet been created.
	 */
	protected StringWriter deferredStr;

	/**
	 *  A PrintWriter wrapper around deferredStr.
	 */
	protected PrintWriter deferred;

	/**
	 *  The set of atoms currently being exported.
	 */
	protected AtomVector atoms = null;

	/**
	 *  A list of atoms that have already been written
	 *  to the current ODL file.
	 */
	protected AtomVector written = null;

	/**
	 *  The <tt>$exit</tt> atom. This is needed to
	 *  identify exit atoms. This is a dynamic
	 *  atom in the AtomDatabase, so it needs to
	 *  be extracted each time.
	 */
	protected Atom exit = null;

	//----------------------------------------------------------------
	//  class variables
	//----------------------------------------------------------------

	/**
	 *  The standard copyright line. This will doubtless change
	 *  at some point.
	 */
	public static final String COPYRIGHT_NOTICE
		= "# Copyright (c) Ogalala Ltd, <info@ogalala.com>";

	//----------------------------------------------------------------
	//  construction
	//----------------------------------------------------------------

	/** Default constructor. */
	public ODLExporter () {}

	//----------------------------------------------------------------
	//  usage
	//----------------------------------------------------------------

	/**
	 *  Export the given set of atoms to the
	 *  specified ODL file.
	 */
	public void export ( AtomVector atoms,
						 String author,
						 String fileComment,
						 String fileName )
		throws IOException
	{
		// if there are no atoms, forget the whole thing
		if ( atoms.size() == 0 )
			return;

		PrintWriter writer = new PrintWriter ( new FileWriter ( fileName ), true );

		export ( atoms,
				 author,
				 fileComment,
				 writer );

		writer.close();
	}

	//----------------------------------------------------------------

	/**
	 *  Export the given set of atoms to the
	 *  specified stream in ODL format.
	 */
	public synchronized void export ( AtomVector atoms,
						 			  String author,
						 			  String fileComment,
									  PrintWriter out )
	{
		// if there are no atoms, forget the whole thing
		if ( atoms.size() == 0 )
			return;

		// initialize
		this.out = out;
		this.atoms = atoms;
		deferredStr = new StringWriter();
		deferred = new PrintWriter( deferredStr );
		written = new AtomVector ();

		// atoms must be sorted into dependency order
		// (in fact AtomVector does this in reverse, so
		// we need to walk the list backwards, but the
		// effect is the same)
		atoms.sort();

		// find the atom that defines an exit
		AtomDatabase db = atoms.get(0).getWorld().getAtomDatabase();
		exit = db.getAtom ( "exit" );

		// write various parts of the ODL file
		writeHeader ( fileComment, author );
		writeAtoms ();
		writeThings ();
		writeExits ();

		out.flush();
	}

	//----------------------------------------------------------------
	//  output blocks
	//----------------------------------------------------------------

	/** Write the standard file header with the given comment. */
	public void writeHeader ( String comment,
							  String author )
	{
		out.println ( "# $" + "Id$" );
		out.println ( "# " + comment );
		out.println ( "# Generated by ODLExporter for "
					  + author
					  + ", "
					  + new Date() );
		out.println ( COPYRIGHT_NOTICE );
		out.println ();
		out.println ();
	}

	//----------------------------------------------------------------

	/** Write all the atoms from the list. */
	public void writeAtoms ()
	{
		out.println ( "#### ATOMS ####" );
		out.println ();

		// proceed backwards through the atom vector,
		// writing any atom that isn't a thing
		for ( int i = atoms.size() - 1; i >= 0; i-- )
		{
			Atom atom = atoms.get(i);

			if ( atom.getClassName().equals("Atom") )
				writeOneAtom( atom, "atom" );
		}

		out.println ();
	}

	//----------------------------------------------------------------

	/** Write all the things from the list. */
	public void writeThings ()
	{
		out.println ( "#### THINGS ####" );
		out.println ();

		// proceed backwards through the atom vector,
		// writing any atom that isn't an atom or an
		// exit
		for ( int i = atoms.size() - 1; i >= 0; i-- )
		{
			Atom atom = atoms.get(i);

			if ( ! atom.getClassName().equals("Atom")
				 && ! atom.isDescendantOf ( exit ) )
				writeOneAtom( atom, "thing" );
		}

		out.println ();
	}

	//----------------------------------------------------------------

	/**
	 *  Write the exits table (including any property
	 *  definitions deferred due to dependencies)
	 */
	public void writeExits ()
	{
		out.println ( "#### EXITS ####" );
		out.println ();

		out.println ( "exits" );
		out.println ( "{" );

		for ( int i = atoms.size() - 1; i >= 0; i-- )
		{
			Atom atom = atoms.get(i);

			if ( atom.isDescendantOf ( exit ) )
				writeExit( atom );
		}

		// dump any deferred property definitions
		out.print ( deferredStr.toString() );

		out.println ( "}" );
	}

	//----------------------------------------------------------------

	/**
	 *  Write a single atom's definition in ODL format.
	 *  Atom properties that are dependent on atoms
	 *  in the atom list that haven't yet been written
	 *  are deferred to be output in the exits table.

	 @param atom  The atom to be written as ODL.
	 @param type  Either "atom" or "thing".

	 */
	public void writeOneAtom ( Atom atom,
							   String type )
	{
		// I'm going to trust that the AtomVector
		// sort does actually guarantee the correct
		// ordering for parental dependencies, and not
		// bother to check that here -- if this turns
		// out to be incorrect, do something about it
		// #### HERE ####

		// if there are any documentation comments for
		// this atom, write them first

		Object comments = atom.getField( "__" + atom.getID() );
		if ( comments != null && comments instanceof String )
			out.println ( StringUtil.wrap ( ((String) comments).trim(),
											72,
											"## ",
											"" ) );

		// print the atom declaration header
		out.print ( type + " " );
		out.print ( atom.getID() + " :" );

		Enumeration parents = atom.getParents();
		while ( parents.hasMoreElements() )
		{
			Atom parent = (Atom) parents.nextElement();
			out.print ( " " + parent.getID() );
		}

		// open the atom block
		out.println();
		out.println( "{" );

		// write out the atom's noun list (if any)
		writeNouns ( atom );

		// write out the atom's location (if any)
		// #### this is almost guaranteed to cause
		// dependency problems -- this will need
		// to be addressed later ####
		writeWhere ( atom );

		// print out all the fields defined on the atom
		// (but if they depend on an atom defined in this
		// file that hasn't already been written, print
		// them to the deferred stream instead)
		Enumeration fields = atom.getFieldNames();
		while ( fields.hasMoreElements() )
		{
			writeField ( atom, (String) fields.nextElement() );
		}

		// close the atom block
		out.println( "}" );
		out.println();

		// this atom has now been written
		written.put ( atom );
	}

	//----------------------------------------------------------------
	//  output atom constituents
	//----------------------------------------------------------------

	/**
	 *  Write an exit declaration.
	 */
	public void writeExit ( Atom atom )
	{
		System.out.println ( "Writing exit " + atom );

		if ( atom == null
			 || ! atom.isDescendantOf ( exit ))
			return;

		// each exit must be declared only once, and that
		// includes both ends
		if ( written.contains ( atom ) )
			return;

		// first, write any comments associated with this exit
		Object comments = atom.getField( "__" + atom.getID() );
		if ( comments != null && comments instanceof String )
		{
			out.println ( StringUtil.wrap ( ((String) comments).trim(),
											68,
											"\t## ",
											"" ) );
			System.out.println ( "Wrote exit comments" );
		}

		// extract the various parts of the exit structure
		Container sourceRoom = (Container) atom.getContainer();
		Container destRoom = (Container) atom.getField ( "destination" );
		Atom destExit = (Atom) atom.getField ( "other_side" );

		// add both ends of the exit to the written list
		written.addElement ( atom );
		if ( destExit != null )
			written.addElement ( destExit );

		// derive the relevant string chunks
		String fromDir = getDirections ( sourceRoom, atom );
		String toDir = getDirections ( destRoom, destExit );
		String fromClass = getTemplate ( atom );
		String toClass = getTemplate ( destExit );
		String fromRoom = sourceRoom.getID();
		String toRoom = destRoom.getID();

		// construct the actual exit spec from these fields
		if ( fromClass == null )
			fromClass = " ";
		else
			fromClass = " (" + fromClass + ") ";

		if ( toDir == null )
			toDir = " ";
		else
			toDir = " " + toDir;

		if ( toClass == null )
			toClass = "";
		else
			toClass = " (" + toClass + ")";

		// the actual exit declaration
		out.println ( "\t" + fromRoom + " " + fromDir + fromClass
					  + "= " + toRoom + toDir + toClass );

		// export any fields defined on these exits
		writeExitFields ( sourceRoom, atom );
		writeExitFields ( destRoom, destExit );
	}

	//----------------------------------------------------------------

	/**
	 *  Write the fields defined on an exit using the
	 *  <tt>room.direction.field&nbsp;=&nbsp;value</tt>
	 *  syntax. The fields "destination", "direction"
	 *  and "other_side" are skipped, since they are
	 *  generated by !DIG.
	 */
	public void writeExitFields ( Container room,
								  Atom exit )
	{
		// can't work with amateurs
		if ( room == null || exit == null )
			return;

		String roomName = room.getID();
		String exitDir = (String) exit.getField("direction");
		if ( exitDir == null )
			return;
		String exitSpec = roomName + "." + exitDir + ".";

		// iterate through the exit's fields, writing any
		// that need writing
		Enumeration enum = exit.getFieldNames();
		while ( enum.hasMoreElements() )
		{
			String field = (String) enum.nextElement();
			if ( field.equals( "direction" )
				 || field.equals( "destination" )
				 || field.equals( "other_side" )
				 || field.startsWith ( "_" ) )
				continue;

			// write any comments associated with this field
			Object comments = exit.getField( "__" + field );
			if ( comments != null && comments instanceof String )
			{
				// precede comments with a newline for clarity
				out.println ();
				out.println ( StringUtil.wrap ( ((String) comments).trim(),
												68,
												"\t## ",
												"" ) );
			}

			// write the actual field value
			String value = AtomData.toString ( exit.getField( field ) );

			// AtomData.toString doesn't quote strings, so add quotes
			// unless they're there already
			if ( (AtomData.getFieldType(exit.getField(field)) == AtomData.STRING)
				 && ! value.startsWith("\"") )
				value = "\"" + value + "\"";

			out.print ( "\t" + exitSpec + field + " = " );
			out.println ( StringUtil.wrap ( value,
											60,
											"",  		// first line no prefix
											"\t\t\t",	// subsequent lines indented
											"",			// last line no suffix
											"\\" ) );	// other lines end with '\'
		}
	}

	//----------------------------------------------------------------

	/**
	 *  Write the definition of a named field in ODL format.
	 *  If the field's value depends on an atom in the current
	 *  file that has not yet been written, the definition is
	 *  deferred for inclusion in the exits block.
	 *  <p>
	 *  Note that any fields whose names begin with an underscore
	 *  are omitted (in general these will contain documentation
	 *  for non-underscore fields, or special values such as "_nouns"
	 */
	public void writeField ( Atom atom,
							 String field )
	{
		if ( field.startsWith("_") )
			return;

		// check for dependencies and compare them to the atoms
		// list and the written list to see whether this stuff
		// needs to be written now or deferred
		PrintWriter dst;
		if ( checkDependencies ( atom.getField ( field ) ) )
			dst = deferred;
		else
			dst = out;

		// first, write any comments associated with this field
		Object comments = atom.getField( "__" + field );
		if ( comments != null && comments instanceof String )
		{
			// precede comments with a newline for clarity
			dst.println ();
			dst.println ( StringUtil.wrap ( ((String) comments).trim(),
											68,
											"\t## ",
											"" ) );
		}

		// then write the actual field value
		String value = AtomData.toString ( atom.getField( field ) );

		// AtomData.toString doesn't quote strings, so add quotes
		// unless they're there already
		if ( (AtomData.getFieldType(atom.getField(field)) == AtomData.STRING)
			 && ! value.startsWith("\"") )
			value = "\"" + value + "\"";

		dst.print ( "\t" );

		if ( dst == deferred )
		{
			out.println ( "\t# NOTE: property "
						  + field
						  + " deferred to exits block" );
			dst.print ( atom.getID() + "." );
		}

		dst.print ( field + " = " );
		dst.println ( StringUtil.wrap ( value,
										60,
										"",  		// first line no prefix
										"\t\t\t",	// subsequent lines indented
										"",			// last line no suffix
										"\\" ) );	// other lines end with '\'
	}

	//----------------------------------------------------------------

	/**
	 *  Write the nouns for a given atom in ODL format.
	 */
	public void writeNouns ( Atom atom )
	{
		Vector nouns = atom.getWorld().getVocabulary().getAtomNouns( atom );
		if ( nouns == null
			 || nouns.size() == 0 )
			return;

		// are nouns allowed to have comments? I don't
		// think so, but I'm not sure -- check this, and
		// if necessary add it here ####

		out.print ( "\t__nouns = [ " );

		Enumeration enum = nouns.elements();
		while ( enum.hasMoreElements() )
		{
			out.print ( (String) enum.nextElement() );
			out.print ( " " );
		}

		out.println ( "]" );
	}

	//----------------------------------------------------------------

	/**
	 *  Write the location of the given atom (thing) in ODL
	 *  format. Note that this may give rise to dependency
	 *  problems. One solution (and I use the term loosely)
	 *  would be to change the ODL compiler to compile an
	 *  "atom._where = $place" declaration in an exits block
	 *  into "!move atom place", and use the same deferral
	 *  mechanism as above.
	 */
	public void writeWhere ( Atom atom )
	{
		if ( ! ( atom instanceof Thing ) )
			return;

		Thing thing = (Thing) atom;
		Atom where = thing.getContainer();

		if ( where == null )
			return;

		// as with proper properties, write either to the output
		// stream or to the deferred stream
		if ( isDependent ( where ) )
		{
			out.println ( "\t# NOTE: property _where deferred to exits block" );
			deferred.println ( "\t"
							   + atom.getID()
							   + "._where = $"
							   + where.getID() );
		}
		else
		{
			out.println ( "\t_where = $" + where.getID() );
		}
	}

	//----------------------------------------------------------------
	//  utilities
	//----------------------------------------------------------------

	/**
	 *  Determine whether the given property of the given
	 *  atom depends on other atoms declared in the same
	 *  file that have not yet been written. This function
	 *  may call itself recursively if the object is a list
	 *  or table, and may cause a stack overflow if the list
	 *  or table contains circular references.

	 @return <tt>true</tt> if the object has unresolved dependencies,
	         <tt>false</tt> otherwise.
	 */
	public boolean checkDependencies ( Object value )
	{
		Enumeration enum;

		if ( value instanceof Atom )
			return isDependent ( (Atom) value );
		else if ( value instanceof Dictionary )
			enum = ((Dictionary) value).elements();
		else if ( value instanceof Vector )
			enum = ((Vector) value).elements();
		else
			return false;

		while ( enum.hasMoreElements() )
		{
			if ( checkDependencies ( enum.nextElement() ) )
				return true;
		}

		return false;
	}

	//----------------------------------------------------------------

	/**
	 *  Check whether a specific atom is local and unwritten.
	 */
	public boolean isDependent ( Atom atom )
	{
		return ( atoms.contains( atom )
				 && (! written.contains( atom )) );
	}

	//----------------------------------------------------------------

	/**
	 *  Get the ID of the atom used as a template when
	 *  creating the given atom. In general, this will
	 *  be its direct parent. If there is more than one
	 *  parent, it is the one furthest down the inheritance
	 *  list.
	 */
	public String getTemplate ( Atom atom )
	{
		if ( atom == null )
			return null;

		Enumeration enum = atom.getParents();
		AtomVector parentList = new AtomVector();
		while ( enum.hasMoreElements() )
			parentList.put ( (Atom) enum.nextElement() );

		parentList.sort();

		return parentList.get( parentList.size() - 1 ).getID();
	}

	//----------------------------------------------------------------

	/**
	 *  Get a string specifying all the directions by
	 *  which the given room can be left via the
	 *  given exit.
	 */
	public String getDirections ( Container room,
								  Atom exit )
	{
		// a non-existent exit corresponds to the
		// pseudo-direction "none"
		if ( room == null || exit == null )
			return "none";

		StringVector directions = new StringVector();

		// manually work through all the directions in
		// the exit table, and add any that correspond to
		// the given exit to the directions list (as strings)
		if ( room.getExit ( ExitTable.DIR_NORTH ) == exit )
			directions.put ( ExitTable.CMD_NORTH );
		if ( room.getExit ( ExitTable.DIR_SOUTH ) == exit )
			directions.put ( ExitTable.CMD_SOUTH );
		if ( room.getExit ( ExitTable.DIR_WEST ) == exit )
			directions.put ( ExitTable.CMD_WEST );
		if ( room.getExit ( ExitTable.DIR_EAST ) == exit )
			directions.put ( ExitTable.CMD_EAST );
		if ( room.getExit ( ExitTable.DIR_NORTHWEST ) == exit )
			directions.put ( ExitTable.CMD_NORTHWEST );
		if ( room.getExit ( ExitTable.DIR_SOUTHEAST ) == exit )
			directions.put ( ExitTable.CMD_SOUTHEAST );
		if ( room.getExit ( ExitTable.DIR_SOUTHWEST ) == exit )
			directions.put ( ExitTable.CMD_SOUTHWEST );
		if ( room.getExit ( ExitTable.DIR_NORTHEAST ) == exit )
			directions.put ( ExitTable.CMD_NORTHEAST );
		if ( room.getExit ( ExitTable.DIR_UP ) == exit )
			directions.put ( ExitTable.CMD_UP );
		if ( room.getExit ( ExitTable.DIR_DOWN ) == exit )
			directions.put ( ExitTable.CMD_DOWN );
		if ( room.getExit ( ExitTable.DIR_IN ) == exit )
			directions.put ( ExitTable.CMD_IN );
		if ( room.getExit ( ExitTable.DIR_OUT ) == exit )
			directions.put ( ExitTable.CMD_OUT );

		// stick any identified directions together
		if ( directions.size() == 0 )
			return "";

		else if ( directions.size() == 1 )
			return directions.get(0);

		String buildUp = directions.get(0);
		for ( int i = 1; i < directions.size(); i++ )
			buildUp += "," + directions.get(i);

		return buildUp;
	}

	//----------------------------------------------------------------
}