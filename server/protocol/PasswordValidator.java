// $Id: PasswordValidator.java,v 1.3 1998/08/25 10:58:04 matt Exp $
// A class to handle password checking chores
// Matthew Caldwell, 11 May 1998
// Copyright (c) Ogalala Ltd <info@ogalala.com>

package com.ogalala.crypt;

import java.util.Random;

/**
 *  The PasswordValidator class implements some functionality
 *  necessary for doing SHA-digest password authentication. It
 *  is used as a utility by the actual transaction classes
 *  PasswordTransactionClient and PasswordTransactionServer.
 *  Although this offers little real functionality of its own,
 *  it centralizes the process so that the client and server
 *  should always be in sync, and it enforces the order of the
 *  different steps.
 *  <p>
 *  The password transaction is a three-stage process:
 *  <ul>
 *  <li>Specify a random seed to hash the password with
 *  <li>Specify the password itself
 *  <li>Generate the hash
 *  </ul>
 *  For the server, this is preceded by a stage in which the
 *  random message is generated and followed by a validation stage,
 *  in which the generated hash is compared with that sent
 *  by the client.
 *  <p>
 *  The shared stages correspond to the methods <tt>setSeed()</tt>
 *  and <tt>getHash()</tt>. The server stages are implemented in
 *  the methods <tt>getSeed()</tt> and <tt>authenticate()</tt>.
 
 @see com.ogalala.server.PasswordLogin
 @see com.ogalala.client.PasswordNegotiator
 
 */
public class PasswordValidator
{
	//-------------------------------------------------------------------
	
	// instance variables
	
	/**
	 *  The SHA hash used for validation.
	 */
	private SHA hash = new SHA();
	
	/**
	 *  A string version of the final hash.
	 */
	private String hashStr = null;
	
	// Private state constants.
	
	/**
	 *  Constant indicating the validation process has not begun.
	 */
	private static final int UNINITIALIZED = 0;
	
	/**
	 *  Constant indicating the seed message has been set.
	 */
	private static final int SEEDED = 1;
	
	/**
	 *  Constant indicating the password has been set and the
	 *  hash generated.
	 */
	private static final int HASHED = 2;
	
	/**
	 *  The stage of the validation that's been reached so far. The
	 *  methods implementing the different stages will not execute
	 *  in the wrong state.
	 */
	private int state = UNINITIALIZED;
		

	//-------------------------------------------------------------------
	
	/**
	 *  Default constructor.
	 */
	public PasswordValidator ()
	{
	}
	
	//-------------------------------------------------------------------

	/**
	 *  Generate a random seed value on which to base the hash.
	 *  This remembers the seed internally (equivalent to a
	 *  call to <tt>setSeed</tt>), and can only be called when
	 *  the validator is in a virginal state (ie, immediately after
	 *  construction or a call to <tt>reset()</tt>). This is called
	 *  by the server side only.
	 *  <p>
	 *  Throws an AuthenticationException if called in the wrong state.
	 
	 @see #setSeed
	 @return  The seed string for this authentication session,
	          a 40-character hex string.
	 @throw com.ogalala.password.AuthenticationException
	 
	 */
	public synchronized String getSeed ()
		throws AuthenticationException
	{
		if ( state != UNINITIALIZED )
			throw ( new AuthenticationException(
						"PasswordValidator.getSeed(): called in wrong state" ) );
		
		// get some random data
		Random rng = new Random();
		byte[] junk = new byte[ 20 ];
		
		rng.nextBytes(junk);
		
		// convert it into string form
		String seed = CryptUtilities.hexString( junk );
		
		// add it to the hash locally and set state
		hash.update( seed );
		state = SEEDED;
		
		// return it
		return seed;
	}
	
	//-------------------------------------------------------------------
	
	/**
	 *  Specify the random seed value on which to base the hash.
	 *  This can only be called when the validator is in a virginal
	 *  state (ie, immediately after construction or a call to
	 *  <tt>reset()</tt>). This is called by the client side only.
	 *  <p>
	 *  Throws an AuthenticationException if called in the wrong state.
	 
	 @see #getSeed
	 @param seed  A seed string, as generated by <tt>getSeed()</tt>
	              on the server side.
	 @throw com.ogalala.password.AuthenticationException
	 
	 */
	public synchronized void setSeed ( String seed )
		throws AuthenticationException
	{
		if ( state != UNINITIALIZED )
			throw ( new AuthenticationException(
						"PasswordValidator.setSeed(): called in wrong state" ) );
		
		hash.update( seed );
		state = SEEDED;
	}
	
	//-------------------------------------------------------------------

	/**
	 *  Get the hash value using the supplied password. This can only
	 *  be called if the seed has already been specified. It is likely
	 *  to be called only by the client, though the server may need
	 *  to do so in some circumstances.
	 *  <p>
	 *  Throws an AuthenticationException if called in the wrong state.
	 
	 @param passwd  The password to be hashed.
	 @return  The hash value of the seed and password, a 40-character hex string.
	 @throw com.ogalala.password.AuthenticationException
	 
	 */
	public synchronized String getHash ( String passwd )
		throws AuthenticationException
	{
		if ( state != SEEDED )
			throw ( new AuthenticationException(
						"PasswordValidator.getHash(): called in wrong state" ) );
		
		hash.update ( passwd );
		hashStr = hash.getHashString();
		state = HASHED;
		
		return hashStr;
	}
	
	//-------------------------------------------------------------------
	
	/**
	 *  Get a previously generated hash again. This can only be called
	 *  if the hash has in fact been generated.
	 *  <p>
	 *  Throws an AuthenticationException if called in the wrong state.
	 
	 @return  The previously generated hash value.
	 @throw com.ogalala.password.AuthenticationException
	 
	 */
	public String getHash ()
		throws AuthenticationException
	{
		if ( state != HASHED )
			throw ( new AuthenticationException(
						"PasswordValidator.getHash(): called in wrong state" ) );
		return hashStr;
	}

	//-------------------------------------------------------------------

	/**
	 *  Compare a received string against that generated from the
	 *  correct password. This can only be called if the seed has
	 *  already been specified, and is only called by the server.
	 *  <p>
	 *  Throws an AuthenticationException if called in the wrong state.
	 
	 @param passwd    The correct password.
	 @return  Whether the password is correct.
	 @param incoming  The authentication string sent by the client.
	 
	 */
	public synchronized boolean authenticate ( String passwd, String incoming )
		throws AuthenticationException
	{
		if ( state != SEEDED )
			throw ( new AuthenticationException(
						"PasswordValidator.authenticate(): called in wrong state" ) );

		return getHash(passwd).equals(incoming.trim());
	}
	
	//-------------------------------------------------------------------
	
	/**
	 *  Return the validator to its virgin, uninitialized state. 
	 */
	public synchronized void reset()
	{
		hash.reset();
		hashStr = null;
		state = UNINITIALIZED;
	}

	//-------------------------------------------------------------------
}